<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html>
  <head>
    <title>common-lisp-pitfalls
    </title>
    <meta http-equiv='content-type' content='text/html; charset=UTF-8' />
    <meta name='auhtor' content='hyotang666' />
    <meta name='generator' content='pages' />
<link rel='stylesheet' href='../css/css.css' type='text/css' />
  </head>
<body><h1>Common Lisp Pitfalls</h1>

<h2>Meta info</h2>

<h3>対象読者</h3>

<p>複数の処理系で可能な限り可搬的になるようコードを書きたい初級〜中級CLer。</p>

<h3>現時点での対象処理系</h3>

<p>SBCL、CLISP、ECL、CCL</p>

<h2>Introduction</h2>

<p>僕がハマってきたピットフォール群をメモ的にコレクションしていきたい。</p>

<p>ピットフォールは主に以下の種類に分けられる。</p>

<ul>
<li>仕様上未定義と定義されている（明示的未定義）。</li>
<li>仕様上触れられていない（暗黙裏に未定義）。</li>
<li>仕様上明確に定義されているが難解。</li>
<li>仕様上明確に定義されているが独自拡張している処理系あり。</li>
<li>処理系が仕様に違反。</li>
</ul>

<p>先頭から順番に読むもよし、気になるオペレータ名で検索をかけるもよし。</p>

<p>なお、記事が追加される場合は先頭に追加していくこととする。
また、項目は重複する可能性があるものとする。</p>

<h2>*PRINT-LENGTH*</h2>

<p>プリティプリンタ周りの実装は可搬的でないケースが多い。
構造体の表示に関しては仕様でも触れられていない。
CCLでは型名もスロット名も「リスト内の要素」と解釈されている。
SBCL,ECLでは型名はカウントせず、スロット：値の対を一要素と解釈されている。
CLISPでは構造体自体は言わばアトムであると解釈されている。</p>

<pre><code><span class="code">=&gt; FOO
<span class="paren1">(<span class="code"><i><span class="symbol">defstruct</span></i> foo a b c d</span>)</span>
<span class="paren1">(<span class="code"><i><span class="symbol">let</span></i><span class="paren2">(<span class="code"><span class="paren3">(<span class="code"><span class="special">*print-length*</span> 2</span>)</span></span>)</span>
  <span class="paren2">(<span class="code">print<span class="paren3">(<span class="code">make-foo <span class="keyword">:a</span> <span class="paren4">(<span class="code">list 1 2 3 4 5</span>)</span></span>)</span></span>)</span></span>)</span>

#+clisp
#S<span class="paren1">(<span class="code">FOO <span class="keyword">:A</span> <span class="paren2">(<span class="code">1 2 ...</span>)</span> <span class="keyword">:B</span> NIL <span class="keyword">:C</span> NIL <span class="keyword">:D</span> NIL</span>)</span>

#+<span class="paren1">(<span class="code">or sbcl ecl</span>)</span>
#S<span class="paren1">(<span class="code">FOO <span class="keyword">:A</span> <span class="paren2">(<span class="code">1 2 ...</span>)</span> <span class="keyword">:B</span> NIL ...</span>)</span>

#+ccl
#S<span class="paren1">(<span class="code">FOO <span class="keyword">:A</span> ...</span>)</span></span></code></pre>

<h2>READ</h2>

<p>これは処理系のバグに相当するが、<code>+.</code>や<code>-.</code>はAnsiスタンダードでは数ではないとされているが、ECLでは０に解釈される。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">read-from-string <span class="string">"+."</span></span>)</span> =&gt; implementation-dependent.
                        <span class="comment">; Symbol +. in spec.
</span>                        <span class="comment">; 0 in ECL.</span></span></code></pre>

<p>通常問題になることは無いと思われるが、Common LispでCommon Lispのパーザを書き、それをテストしたところ遭遇した。</p>

<h2>BACKQUOTE</h2>

<p>バッククォートの実装は処理系依存である。
多くの処理系でバッククォートはマクロに展開され、すなわちコンパイル時に等価なフォームが生成されるが、そうでない処理系も存在する。
具体的にはCCLはフォーム生成をリード時に行う。</p>

<pre><code><span class="code">'`<span class="paren1">(<span class="code">hoge ,@<span class="paren2">(<span class="code">cdr '<span class="paren3">(<span class="code">1 2 3</span>)</span></span>)</span></span>)</span> =&gt; implementation-dependent.
                          <span class="comment">; `(HOGE ,`(CDR '(1 2 3))) in many impls.
</span>                          <span class="comment">; (LIST* 'HOGE (CDR '(1 2 3))) in CCL.</span></span></code></pre>

<h2>SIGNAL</h2>

<p><code>SIGNAL</code>の振る舞いは、受け取ったコンディションを元にハンドラを探し、ハンドラがあればコールしてまわり、どのハンドラもコントロールフロー制御をしなければ最終的に<code>NIL</code>を返すというものである。</p>

<p>トップレベルにハンドラがあるかどうかは処理系依存となる。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">signal 'error</span>)</span> =&gt; implementation-dependent. NIL or invokes debugger.</span></code></pre>

<h2><code>*STANDARD-OUTPUT*</code> <code>*STANDARD-INPUT*</code></h2>

<p>多くの処理系では、たとえば<code>*STANDARD-OUTPUT*</code>に<code>*STANDARD-INPUT*</code>を束縛することはエラーとなるが、そうでない処理系も存在する。
たとえばCCLでは両シンボルは<code>*TERMINAL-IO*</code>へのaliasとして機能している。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">let</span></i><span class="paren2">(<span class="code"><span class="paren3">(<span class="code"><span class="special">*standard-output*</span> <span class="special">*standard-input*</span></span>)</span></span>)</span>
  ...</span>)</span>
=&gt; implementation-dependent. Error or works.</span></code></pre>

<pre><code><span class="code"><span class="paren1">(<span class="code">output-stream-p <span class="special">*standard-input*</span></span>)</span> =&gt; implementation-dependent. T in CCL.</span></code></pre>

<p>通常このような馬鹿げたコードを書くことはないが、「アウトプットストリームを期待している関数にインプットストリームを渡すとエラーになる」という文脈のテストコードを書く際などに、想定外に成功するという形で現れる。</p>

<h2>CASE ECASE CCASE</h2>

<p><code>NIL</code>ないし<code>T</code>をキーにしたい場合は必ず括弧にくくらねばならない。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">case var
  <span class="paren2">(<span class="code">nil <span class="keyword">:this-clause-is-never-chosen.</span></span>)</span>
  <span class="paren2">(<span class="code"><span class="paren3">(<span class="code">nil</span>)</span> <span class="keyword">:ok.</span></span>)</span>
  <span class="paren2">(<span class="code">t <span class="keyword">:this-clause-is-treated-as-default-clause.</span></span>)</span>
  <span class="paren2">(<span class="code"><span class="paren3">(<span class="code">t</span>)</span> <span class="keyword">:ok.</span></span>)</span></span>)</span></span></code></pre>

<h2>LOOP</h2>

<p><code>:MAXIMIZE</code>や<code>:MINIMIZE</code>が実行されなかった場合の返り値は未定義。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">loop</span></i> <span class="keyword">:for</span> i <span class="keyword">:in</span> <span class="paren2">(<span class="code"></span>)</span> <span class="keyword">:minimize</span> i</span>)</span> =&gt; unspecified. NIL or 0.</span></code></pre>

<p>終端チェック節の後に変数束縛節を使うのはinvalid。
期待通り動く処理系とそうでない処理系とがある。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">loop</span></i> <span class="keyword">:for</span> i <span class="keyword">:in</span> '<span class="paren2">(<span class="code">1 1 1 <span class="character">#\1</span></span>)</span>
      <span class="keyword">:while</span> <span class="paren2">(<span class="code">integerp i</span>)</span>
      <span class="keyword">:for</span> c = <span class="paren2">(<span class="code">code-char i</span>)</span> <span class="comment">; &lt;--- invalid.
</span>      <span class="keyword">:do</span> ...</span>)</span></span></code></pre>

<h2>DEFTYPE</h2>

<p>再帰定義は未定義。
上手く動く処理系とそうでない処理系がある。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">deftype</span></i> strings<span class="paren2">(<span class="code"></span>)</span>
  <span class="paren2">(<span class="code">or null <span class="paren3">(<span class="code">cons string strings</span>)</span></span>)</span></span>)</span>
=&gt; STRINGS
<span class="paren1">(<span class="code">typep <span class="keyword">:hoge</span> strings</span>)</span>
=&gt; unspecified. Works or infinite loop.</span></code></pre>

<p>マクロとしての<code>AND</code>は左から右に評価されるが、型指定子としての<code>AND</code>はその限りではない。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">typep <span class="keyword">:hoge</span> '<span class="paren2">(<span class="code">and integer <span class="paren3">(<span class="code">satisfies evenp</span>)</span></span>)</span></span>)</span>
=&gt; unspecified. Works or signals error.</span></code></pre>

<h2>DOCUMENTATION</h2>

<p>これは処理系のバグに相当するが、ECLではSETFできない。
仕様ではSETF出来る。</p>

<pre><code><span class="code"><span class="comment">;; @ECL
</span><span class="paren1">(<span class="code">setf<span class="paren2">(<span class="code">documentation 'hoge '<i><span class="symbol">function</span></i></span>)</span> <span class="string">"docstring"</span></span>)</span>
=&gt; "docstring"
<span class="paren1">(<span class="code">documentation 'hoge '<i><span class="symbol">function</span></i></span>)</span>
=&gt; NIL</span></code></pre>

<h2>MAKE-STRING-INPUT-STREAM WITH-INPUT-FROM-STRING</h2>

<p>これは処理系独自拡張になるが、ECLでは文字列指定子（string-designator）が使える。</p>

<pre><code><span class="code"><span class="comment">;; @ECL
</span><span class="paren1">(<span class="code"><i><span class="symbol">with-input-from-string</span></i><span class="paren2">(<span class="code">s <span class="keyword">:hoge</span></span>)</span>
  <span class="paren2">(<span class="code">read s</span>)</span></span>)</span>
=&gt; HOGE <span class="comment">; Error in spec.
</span>
<span class="paren1">(<span class="code"><i><span class="symbol">with-input-from-string</span></i><span class="paren2">(<span class="code">s <span class="character">#\c</span></span>)</span>
  <span class="paren2">(<span class="code">read s</span>)</span></span>)</span>
=&gt; C <span class="comment">; Error in spec.</span></span></code></pre>

<h2>SETF FDEFINITION</h2>

<p>SETF可能でも、それがSETF Expanderを持つとは限らない。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">defstruct</span></i> foo bar</span>)</span>
=&gt; FOO
<span class="paren1">(<span class="code">fdefinition '<span class="paren2">(<span class="code">setf foo-bar</span>)</span></span>)</span> =&gt; unspecified.

<span class="paren1">(<span class="code">fdefinition '<span class="paren2">(<span class="code">setf car</span>)</span></span>)</span> =&gt; unspecified.</span></code></pre>

<h2>NIL</h2>

<p>これは可搬的なのだが、分かりづらいので。</p>

<p><code>NIL</code>は型名でもある。
型名としての<code>NIL</code>は「無」を表す。
そのためあらゆる型のsubtypeである。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">subtypep nil nil</span>)</span> =&gt; T</span></code></pre>

<p>また、「無」を表すので、けしてどの型でもない。
すなわち自分自身でもない。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">typep nil nil</span>)</span> =&gt; NIL</span></code></pre>

<p>値としての<code>NIL</code>の型名は<code>NULL</code>である。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">typep nil 'null</span>)</span> =&gt; T</span></code></pre>

<p>筆者個人は例えば以下のようなコードを書き、</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">typep '<span class="paren2">(<span class="code">0</span>)</span> '<span class="paren2">(<span class="code">cons <span class="paren3">(<span class="code">eql 0</span>)</span> nil</span>)</span></span>)</span></span></code></pre>

<p><code>T</code>を期待するも<code>NIL</code>が返ってきて、「何故だ」と悩んだ挙句、「あぁ、<code>NIL</code>じゃない、<code>NULL</code>だ」となることが、まま、ある。</p>

<h2>SYMBOL</h2>

<p>エスケープされた文字を含むシンボルの表示方法はポータブルではない。</p>

<pre><code><span class="code">\#hoge
=&gt; |#HOGE|
<span class="comment">; otherwise
</span>=&gt; \#HOGE</span></code></pre>

<h2>PATHNAME</h2>

<p>リテラルで書く場合、変な値が入る場合がある。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">pathname-version #P<span class="string">""</span></span>)</span> =&gt; :NEWEST</span></code></pre>

<p>これは処理系独自拡張なのだが、シンボルを受け付ける処理系もある。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">pathname <span class="keyword">:/foo/bar/bazz</span></span>)</span> =&gt; #P"/foo/bar/bazz" <span class="comment">; Error in spec.</span></span></code></pre>

<h2>*</h2>

<p>０を掛けた場合、０になるとは限らない。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">* 0 0.0</span>)</span> =&gt; 0 or 0.0</span></code></pre>

<h2>CONDITION</h2>

<p><code>PRINC</code>した場合、メッセージが表示されるとは限らない。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">princ <span class="paren2">(<span class="code">nth-value 1 <span class="paren3">(<span class="code">ignore-errors <span class="paren4">(<span class="code">/ 2 0</span>)</span></span>)</span></span>)</span></span>)</span>
=&gt; unspecified. "Division by zero." or #&lt;DIVISION-BY-ZERO #X123456&gt;</span></code></pre>

<h2>SYMBOL-FUNCTION FDEFINITION</h2>

<p>シンボルがマクロや特殊形式の場合、関数オブジェクトが入っているとは限らない。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">symbol-function 'when</span>)</span> =&gt; unspecified.</span></code></pre>

<h2>CONCATENATE</h2>

<p>これは処理系独自拡張なのだが、SEQUENCE-DESIGNATORとして<code>ARRAY</code>を受け付ける処理系もある。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">concatenate 'array #<span class="paren2">(<span class="code">1 2 3</span>)</span> #<span class="paren2">(<span class="code">4 5 6</span>)</span></span>)</span> =&gt; #<span class="paren1">(<span class="code">1 2 3 4 5 6</span>)</span> <span class="comment">; Error in many impls.</span></span></code></pre>

<h2>COERCE</h2>

<p>シーケンスを配列に出来る処理系とそうでない処理系がある。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">coerce '<span class="paren2">(<span class="code">1 2 3</span>)</span> 'array</span>)</span> =&gt; implementation-dependent. #<span class="paren1">(<span class="code">1 2 3</span>)</span> or signals error.</span></code></pre>

<h2>MAKE-ARRAY</h2>

<p>どのような値で初期化されるかは未定義。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">make-array 1</span>)</span> =&gt; unspecified. #<span class="paren1">(<span class="code">0</span>)</span> or #<span class="paren1">(<span class="code">nil</span>)</span></span></code></pre>

<footer>
  <a href='../index.html'>Index
  </a>
</footer>
</body>
</html>