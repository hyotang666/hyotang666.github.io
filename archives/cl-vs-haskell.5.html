<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html>
  <head>
    <title>cl-vs-haskell.5
    </title>
    <meta http-equiv='content-type' content='text/html; charset=UTF-8' />
    <meta name='auhtor' content='hyotang666' />
    <meta name='generator' content='pages' />
<link rel='stylesheet' href='../css/css.css' type='text/css' />
  </head>
<body><h1>Common Lisp vs Haskell, Chapter 5</h1>

<h2>Meta note</h2>

<h3>対象読者</h3>

<p><a href="cl-vs-haskell.4.html" >前章</a>を読了済みの者。</p>

<h2>Introduction</h2>

<p>本稿は「すごいH本」の内容をCommon Lispに翻訳しながらCLerがHaskellを学ぶその第5章である。
本章のテーマは高階関数である。
デフォルトで関数がカリー化されているHaskellのシンプルで美しい筆記には目を見張るものがある。
また、デフォルトで遅延評価がされていることによる効率の良さも素晴らしい。
さて、それに対してCommon Lispはというと、それなりに健闘しているのではないかと思う。
Haskellはまさに関数型の記述を行うための言語だ。
それに対しCommon Lispはけして関数型の記述を行うためだけの言語ではない。
その割にはそれっぽいアプローチもしっかり取れてしまうあたりマルチパラダイムの面目躍如であろう。
本章のハイライトは、関数合成のためのリーダマクロを導入、SERIESが想定外の大活躍といったあたりか。
中級CLerにとっては面白い内容になっているのではないかと思われる。
割と長文であるし、中身も濃いと思うのでお暇な時にどうぞ。</p>

<h1>5</h1>

<h2>5.1</h2>

<h3>section</h3>

<pre><code><span class="code"><span class="function">divideByTen</span> <span class="keyword">::</span> <span class="paren1">(<span class="code"><span class="variable">Floating</span> a</span>)</span> <span class="atom">=&gt;</span> a <span class="keyword">-&gt;</span> a
<span class="function">devideByTen</span> <span class="keyword">=</span> <span class="paren1">(<span class="code"><span class="atom">/</span>10</span>)</span>
<span class="function">ghci</span><span class="atom">&gt;</span> devideByTen 200
<span class="function">20</span><span class="atom">.</span>0
<span class="function">ghci</span><span class="atom">&gt;</span> 200 <span class="atom">/</span> 10
<span class="function">20</span><span class="atom">.</span>0
<span class="function">ghci</span><span class="atom">&gt;</span> <span class="paren1">(<span class="code"><span class="atom">/</span>10</span>)</span> 200
<span class="function">20</span><span class="atom">.</span>0</span></code></pre>

<p>Common Lispの関数はカリー化されていない。
部分適用された関数が欲しいなら、ALEXANDRIAの<code>CURRY</code>、<code>RCURRY</code>を使う。
また、合成には同じくALEXANDRIAの<code>COMPOSE</code>が使える。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">declaim<span class="paren2">(<span class="code">ftype<span class="paren3">(<span class="code"><i><span class="symbol">function</span></i><span class="paren4">(<span class="code">float</span>)</span>float</span>)</span>/10</span>)</span></span>)</span>
<span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> /10 <span class="paren2">(<span class="code">float</span>)</span>
  <span class="paren2">(<span class="code">float<span class="paren3">(<span class="code">/ float 10</span>)</span></span>)</span></span>)</span>
cl-user&gt; <span class="paren1">(<span class="code">/10 200</span>)</span>
20.0
cl-user&gt; <span class="paren1">(<span class="code">float<span class="paren2">(<span class="code">/ 200 10</span>)</span></span>)</span>
20.0
cl-user&gt; <span class="paren1">(<span class="code">funcall <span class="paren2">(<span class="code">alexandria:rcurry <span class="paren3">(<span class="code">alexandria:compose #'float #'/</span>)</span> 10</span>)</span>200</span>)</span>
20.0</span></code></pre>

<p>少々長ったらしいのでリーダマクロを書いてしまおう。
以下のように書けるものとする。</p>

<pre><code><span class="code">#+design
<span class="paren1">(<span class="code">funcall #`<span class="paren2">(<span class="code">% #`<span class="paren3">(<span class="code">+ 'float '/</span>)</span> _ 10</span>)</span>200</span>)</span></span></code></pre>

<p>実装は以下の通り。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> |#`-reader|<span class="paren2">(<span class="code">stream character number</span>)</span>
  <span class="paren2">(<span class="code">declare<span class="paren3">(<span class="code">ignore character number</span>)</span></span>)</span>
  <span class="paren2">(<span class="code"><i><span class="symbol">let</span></i><span class="paren3">(<span class="code"><span class="paren4">(<span class="code">form<span class="paren5">(<span class="code">read stream t t t</span>)</span></span>)</span></span>)</span>
    <span class="paren3">(<span class="code">ecase<span class="paren4">(<span class="code">car form</span>)</span>
      <span class="paren4">(<span class="code">and `<span class="paren5">(<span class="code">alexandria:conjoin ,@<span class="paren6">(<span class="code">cdr form</span>)</span></span>)</span></span>)</span>
      <span class="paren4">(<span class="code">or `<span class="paren5">(<span class="code">alexandria:disjoin ,@<span class="paren6">(<span class="code">cdr form</span>)</span></span>)</span></span>)</span>
      <span class="paren4">(<span class="code">+ `<span class="paren5">(<span class="code">alexandria:compose ,@<span class="paren6">(<span class="code">cdr form</span>)</span></span>)</span></span>)</span>
      <span class="paren4">(<span class="code">% <span class="paren5">(<span class="code">make-form <span class="paren6">(<span class="code">cdr form</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>

<span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> make-form<span class="paren2">(<span class="code">form</span>)</span>
  <span class="paren2">(<span class="code"><i><span class="symbol">flet</span></i><span class="paren3">(<span class="code"><span class="paren4">(<span class="code">underscorep<span class="paren5">(<span class="code">x</span>)</span>
          <span class="paren5">(<span class="code">and <span class="paren6">(<span class="code">symbolp x</span>)</span>
               <span class="paren6">(<span class="code">string= '<span class="keyword">#:_</span> x</span>)</span></span>)</span></span>)</span></span>)</span>
    <span class="paren3">(<span class="code"><i><span class="symbol">let</span></i><span class="paren4">(<span class="code"><span class="paren5">(<span class="code">position<span class="paren6">(<span class="code">position-if #'underscorep form</span>)</span></span>)</span></span>)</span>
      <span class="paren4">(<span class="code"><i><span class="symbol">if</span></i> position
        <span class="paren5">(<span class="code"><i><span class="symbol">progn</span></i> <span class="paren6">(<span class="code">assert <span class="paren1">(<span class="code">not <span class="paren2">(<span class="code">find-if #'underscorep form <span class="keyword">:start</span> <span class="paren3">(<span class="code">1+ position</span>)</span></span>)</span></span>)</span></span>)</span>
               <span class="paren6">(<span class="code"><i><span class="symbol">if</span></i> <span class="paren1">(<span class="code">= 1 position</span>)</span>
                 `<span class="paren1">(<span class="code">alexandria:rcurry ,<span class="paren2">(<span class="code">car form</span>)</span> ,@<span class="paren2">(<span class="code">cddr form</span>)</span></span>)</span>
                 `<span class="paren1">(<span class="code">alexandria:rcurry <span class="paren2">(<span class="code">alexandria:curry ,<span class="paren3">(<span class="code">car form</span>)</span>
                                                       ,@<span class="paren3">(<span class="code">subseq form 1 position</span>)</span></span>)</span>
                                     ,@<span class="paren2">(<span class="code">nthcdr <span class="paren3">(<span class="code">1+ position</span>)</span>form</span>)</span></span>)</span></span>)</span></span>)</span>
        `<span class="paren5">(<span class="code">alexandria:curry ,@form</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<p>リードテーブルは以下の通り。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">named-readtables:defreadtable</span></i> <span class="keyword">:higher-order-syntax</span>
  <span class="paren2">(<span class="code"><span class="keyword">:merge</span> <span class="keyword">:standard</span></span>)</span>
  <span class="paren2">(<span class="code"><span class="keyword">:dispatch-macro-char</span> <span class="character">#\#</span> <span class="character">#\`</span> #'|#`-reader|</span>)</span></span>)</span></span></code></pre>

<h2>5.2</h2>

<pre><code><span class="code"><span class="function">applyTwice</span> <span class="keyword">::</span> <span class="paren1">(<span class="code">a <span class="keyword">-&gt;</span> a</span>)</span> <span class="keyword">-&gt;</span> a <span class="keyword">-&gt;</span> a
<span class="function">applyTwice</span> f x <span class="keyword">=</span> f <span class="paren1">(<span class="code">f x</span>)</span>
<span class="function">gchi</span><span class="atom">&gt;</span> applyTwice <span class="paren1">(<span class="code"><span class="atom">+</span>3</span>)</span> 10
<span class="function">16</span>
<span class="function">ghci</span><span class="atom">&gt;</span> applyTwice <span class="paren1">(<span class="code"><span class="atom">++</span> <span class="string">" HAHA"</span></span>)</span> <span class="string">"HEY"</span>
<span class="string">"HEY HAHA HAHA"</span>
<span class="function">ghci</span><span class="atom">&gt;</span> applyTwice <span class="paren1">(<span class="code"><span class="string">"HAHA "</span> <span class="atom">++</span></span>)</span> <span class="string">"HEY"</span>
<span class="string">"HAHA HAHA HEY"</span>
<span class="function">ghci</span><span class="atom">&gt;</span> applyTwice <span class="paren1">(<span class="code">3<span class="variable">:</span></span>)</span><span class="paren1">[<span class="code">1</span>]</span>
<span class="paren1">[<span class="code">3,3,1</span>]</span></span></code></pre>

<pre><code><span class="code"><span class="paren1">(<span class="code">declaim<span class="paren2">(<span class="code">ftype<span class="paren3">(<span class="code"><i><span class="symbol">function</span></i><span class="paren4">(<span class="code"><i><span class="symbol">function</span></i> t</span>)</span>t</span>)</span>apply-twice</span>)</span></span>)</span>
<span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> apply-twice<span class="paren2">(<span class="code">f x</span>)</span>
  <span class="paren2">(<span class="code">funcall f<span class="paren3">(<span class="code">funcall f x</span>)</span></span>)</span></span>)</span>
cl-user&gt; <span class="paren1">(<span class="code">apply-twice #`<span class="paren2">(<span class="code">% '+ 3</span>)</span>10</span>)</span>
16
cl-user&gt; <span class="paren1">(<span class="code">apply-twice #`<span class="paren2">(<span class="code">% 'uiop:strcat _ <span class="string">" HAHA"</span></span>)</span><span class="string">"HEY"</span></span>)</span>
"HEY HAHA HAHA"
cl-user&gt; <span class="paren1">(<span class="code">apply-twice #`<span class="paren2">(<span class="code">% 'uiop:strcat <span class="string">"HAHA "</span></span>)</span> <span class="string">"HEY"</span></span>)</span>
"HAHA HAHA HEY"
cl-user&gt; <span class="paren1">(<span class="code">apply-twice #`<span class="paren2">(<span class="code">% 'cons 3</span>)</span>'<span class="paren2">(<span class="code">1</span>)</span></span>)</span>
<span class="paren1">(<span class="code">3 3 1</span>)</span></span></code></pre>

<h3>zipWith</h3>

<pre><code><span class="code"><span class="function">zipWith'</span> <span class="keyword">::</span> <span class="paren1">(<span class="code">a <span class="keyword">-&gt;</span> b <span class="keyword">-&gt;</span> c</span>)</span> <span class="keyword">-&gt;</span> <span class="paren1">[<span class="code">a</span>]</span> <span class="keyword">-&gt;</span> <span class="paren1">[<span class="code">b</span>]</span> <span class="keyword">-&gt;</span> <span class="paren1">[<span class="code">c</span>]</span>
<span class="function">zipWith'</span> _ <span class="paren1">[<span class="code"></span>]</span> _ <span class="keyword">=</span> <span class="paren1">[<span class="code"></span>]</span>
<span class="function">zipWith'</span> _ _ <span class="paren1">[<span class="code"></span>]</span> <span class="keyword">=</span> <span class="paren1">[<span class="code"></span>]</span>
<span class="function">zipWith'</span> f <span class="paren1">(<span class="code">x<span class="variable">:</span>xs</span>)</span> <span class="paren1">(<span class="code">y<span class="variable">:</span>ys</span>)</span> <span class="keyword">=</span> f x y <span class="variable">:</span> zipWith f xs ys

<span class="function">ghci</span><span class="atom">&gt;</span> zipWith' <span class="paren1">(<span class="code"><span class="atom">+</span></span>)</span> <span class="paren1">[<span class="code">4,2,5,6</span>]</span> <span class="paren1">[<span class="code">2,6,2,3</span>]</span>
<span class="paren1">[<span class="code">6,8,7,9</span>]</span>
<span class="function">ghci</span><span class="atom">&gt;</span> zipWith' max <span class="paren1">[<span class="code">6,3,2,1</span>]</span> <span class="paren1">[<span class="code">7,3,1,5</span>]</span>
<span class="paren1">[<span class="code">7,3,2,5</span>]</span>
<span class="function">ghci</span><span class="atom">&gt;</span> zipWith' <span class="paren1">(<span class="code"><span class="atom">++</span></span>)</span> <span class="paren1">[<span class="code"><span class="string">"foo "</span>, <span class="string">"bar "</span>, <span class="string">"baz "</span></span>]</span> <span class="paren1">[<span class="code"><span class="string">"fighters"</span>, <span class="string">"hoppers"</span>, <span class="string">"aldrin"</span></span>]</span>
<span class="paren1">[<span class="code"><span class="string">"foo fighters"</span>, <span class="string">"bar hoppers"</span>, <span class="string">"baz aldrin"</span></span>]</span>
<span class="function">ghci</span><span class="atom">&gt;</span> zipWith' <span class="paren1">(<span class="code">zipWith' <span class="paren2">(<span class="code"><span class="atom">*</span></span>)</span></span>)</span> <span class="paren1">[<span class="code"><span class="paren2">[<span class="code">1,2,3</span>]</span>,<span class="paren2">[<span class="code">3,5,6</span>]</span>,<span class="paren2">[<span class="code">2,3,4</span>]</span></span>]</span> <span class="paren1">[<span class="code"><span class="paren2">[<span class="code">3,2,2</span>]</span>,<span class="paren2">[<span class="code">3,4,5</span>]</span>,<span class="paren2">[<span class="code">5,4,3</span>]</span></span>]</span>
<span class="paren1">[<span class="code"><span class="paren2">[<span class="code">3,4,6</span>]</span>,<span class="paren2">[<span class="code">9,20,30</span>]</span>,<span class="paren2">[<span class="code">10,12,12</span>]</span></span>]</span></span></code></pre>

<p>Haskellの<code>zipWith</code>はCommon Lispの<code>MAPCAR</code>に相当する。</p>

<pre><code><span class="code">cl-user&gt; <span class="paren1">(<span class="code">mapcar #'+ '<span class="paren2">(<span class="code">4 2 5 6</span>)</span>'<span class="paren2">(<span class="code">2 6 2 3</span>)</span></span>)</span>
<span class="paren1">(<span class="code">6 8 7 9</span>)</span>
cl-user&gt; <span class="paren1">(<span class="code">mapcar #'max '<span class="paren2">(<span class="code">6 3 2 1</span>)</span>'<span class="paren2">(<span class="code">7 3 1 5</span>)</span></span>)</span>
<span class="paren1">(<span class="code">7 3 2 5</span>)</span>
cl-user&gt; <span class="paren1">(<span class="code">mapcar #'uiop:strcat '<span class="paren2">(<span class="code"><span class="string">"foo "</span> <span class="string">"bar "</span> <span class="string">"baz "</span></span>)</span> '<span class="paren2">(<span class="code"><span class="string">"fighters"</span> <span class="string">"hoppers"</span> <span class="string">"aldrin"</span></span>)</span></span>)</span>
<span class="paren1">(<span class="code"><span class="string">"foo fighters"</span>  <span class="string">"bar hoppers"</span>  <span class="string">"baz aldrin"</span></span>)</span>
cl-user&gt; <span class="paren1">(<span class="code">mapcar #`<span class="paren2">(<span class="code">% 'mapcar '*</span>)</span>'<span class="paren2">(<span class="code"><span class="paren3">(<span class="code">1 2 3</span>)</span><span class="paren3">(<span class="code">3 5 6</span>)</span><span class="paren3">(<span class="code">2 3 4</span>)</span></span>)</span>'<span class="paren2">(<span class="code"><span class="paren3">(<span class="code">3 2 2</span>)</span><span class="paren3">(<span class="code">3 4 5</span>)</span><span class="paren3">(<span class="code">5 4 3</span>)</span></span>)</span></span>)</span>
<span class="paren1">(<span class="code"><span class="paren2">(<span class="code">3 4 6</span>)</span><span class="paren2">(<span class="code">9 20 30</span>)</span><span class="paren2">(<span class="code">10 12 12</span>)</span></span>)</span></span></code></pre>

<h3>flip</h3>

<pre><code><span class="code"><span class="function">flip'</span> <span class="keyword">::</span> <span class="paren1">(<span class="code">a <span class="keyword">-&gt;</span> b <span class="keyword">-&gt;</span> c</span>)</span> <span class="keyword">-&gt;</span> <span class="paren1">(<span class="code">b <span class="keyword">-&gt;</span> a <span class="keyword">-&gt;</span> c</span>)</span>
<span class="function">flip'</span> f <span class="keyword">=</span> g
&nbsp;   <span class="keyword">where</span> g x y <span class="keyword">=</span> f y x
;; or
<span class="function">flip'</span> <span class="keyword">::</span> <span class="paren1">(<span class="code">a <span class="keyword">-&gt;</span> b <span class="keyword">-&gt;</span> c</span>)</span> <span class="keyword">-&gt;</span> b <span class="keyword">-&gt;</span> a <span class="keyword">-&gt;</span> c
<span class="function">flip'</span> f y x <span class="keyword">=</span> f x y

<span class="function">ghci</span><span class="atom">&gt;</span> zip <span class="paren1">[<span class="code">1,2,3,4,5</span>]</span> <span class="string">"hello"</span>
<span class="paren1">[<span class="code"><span class="paren2">(<span class="code">1,'h'</span>)</span>,<span class="paren2">(<span class="code">2,'e'</span>)</span>,<span class="paren2">(<span class="code">3,'l'</span>)</span>,<span class="paren2">(<span class="code">4,'l'</span>)</span>,<span class="paren2">(<span class="code">5,'o'</span>)</span></span>]</span>
<span class="function">ghci</span><span class="atom">&gt;</span> flip' zip <span class="paren1">[<span class="code">1,2,3,4,5</span>]</span> <span class="string">"hello"</span>
<span class="paren1">[<span class="code"><span class="paren2">(<span class="code"><span class="character">'h'</span>,1</span>)</span>,<span class="paren2">(<span class="code"><span class="character">'e'</span>,2</span>)</span>,<span class="paren2">(<span class="code"><span class="character">'l'</span>,3</span>)</span>,<span class="paren2">(<span class="code"><span class="character">'l'</span>,4</span>)</span>,<span class="paren2">(<span class="code"><span class="character">'o'</span>,5</span>)</span></span>]</span>
<span class="function">ghci</span><span class="atom">&gt;</span> zipWith div <span class="paren1">[<span class="code">2,2<span class="keyword">..</span></span>]</span><span class="paren1">[<span class="code">10,8,6,4,2</span>]</span>
<span class="paren1">[<span class="code">0,0,0,0,1</span>]</span>
<span class="function">ghci</span><span class="atom">&gt;</span> zipWith <span class="paren1">(<span class="code">flip' div</span>)</span> <span class="paren1">[<span class="code">2,2<span class="keyword">..</span></span>]</span> <span class="paren1">[<span class="code">10,8,6,4,2</span>]</span>
<span class="paren1">[<span class="code">5,4,3,2,1</span>]</span></span></code></pre>

<p>Haskellの<code>flip</code>はINCF-CLにある。</p>

<pre><code><span class="code">cl-user&gt; <span class="paren1">(<span class="code">map 'list #'cons '<span class="paren2">(<span class="code">1 2 3 4 5</span>)</span> <span class="string">"hello"</span></span>)</span>
<span class="paren1">(<span class="code"><span class="paren2">(<span class="code">1 . <span class="character">#\h</span></span>)</span><span class="paren2">(<span class="code">2 . <span class="character">#\e</span></span>)</span><span class="paren2">(<span class="code">3 . <span class="character">#\l</span></span>)</span><span class="paren2">(<span class="code">4 . <span class="character">#\l</span></span>)</span><span class="paren2">(<span class="code">5 . <span class="character">#\o</span></span>)</span></span>)</span>
cl-user&gt; <span class="paren1">(<span class="code">map 'list <span class="paren2">(<span class="code">incf-cl:flip #'cons</span>)</span>'<span class="paren2">(<span class="code">1 2 3 4 5</span>)</span> <span class="string">"hello"</span></span>)</span>
<span class="paren1">(<span class="code"><span class="paren2">(<span class="code"><span class="character">#\h</span> . 1</span>)</span><span class="paren2">(<span class="code"><span class="character">#\e</span> . 2</span>)</span><span class="paren2">(<span class="code"><span class="character">#\l</span> . 3</span>)</span><span class="paren2">(<span class="code"><span class="character">#\l</span> . 4</span>)</span><span class="paren2">(<span class="code"><span class="character">#\o</span> . 5</span>)</span></span>)</span>
cl-user&gt; <span class="paren1">(<span class="code">mapcar #'truncate '<span class="paren2">(<span class="code">2 2 2 2 2</span>)</span>'<span class="paren2">(<span class="code">10 8 6 4 2</span>)</span></span>)</span>
<span class="paren1">(<span class="code">0 0 0 0 1</span>)</span>
cl-user&gt; <span class="paren1">(<span class="code">mapcar <span class="paren2">(<span class="code">incf-cl:flip #'truncate</span>)</span>'<span class="paren2">(<span class="code">2 2 2 2 2</span>)</span>'<span class="paren2">(<span class="code">10 8 6 4 2</span>)</span></span>)</span>
<span class="paren1">(<span class="code">5 4 3 2 1</span>)</span></span></code></pre>

<h2>5.3</h2>

<h3>map</h3>

<pre><code><span class="code"><span class="function">map</span> <span class="keyword">::</span> <span class="paren1">(<span class="code">a <span class="keyword">-&gt;</span> b</span>)</span> <span class="keyword">-&gt;</span> <span class="paren1">[<span class="code">a</span>]</span> <span class="keyword">-&gt;</span> <span class="paren1">[<span class="code">b</span>]</span>
<span class="function">map</span> _ <span class="paren1">[<span class="code"></span>]</span> <span class="keyword">=</span> <span class="paren1">[<span class="code"></span>]</span>
<span class="function">map</span> f <span class="paren1">(<span class="code">x,xs</span>)</span> <span class="keyword">=</span> f x <span class="variable">:</span> map f xs

<span class="function">ghci</span><span class="atom">&gt;</span> map <span class="paren1">(<span class="code"><span class="atom">+</span>3</span>)</span> <span class="paren1">[<span class="code">1,5,3,1,6</span>]</span>
<span class="paren1">[<span class="code">4,8,6,4,9</span>]</span>
<span class="function">ghci</span><span class="atom">&gt;</span> map <span class="paren1">(<span class="code"><span class="atom">++</span> <span class="string">"!"</span></span>)</span><span class="paren1">[<span class="code"><span class="string">"BIFF"</span>, <span class="string">"BANG"</span>, <span class="string">"POW"</span></span>]</span>
<span class="paren1">[<span class="code"><span class="string">"BIFF!"</span>,<span class="string">"BANG!"</span>,<span class="string">"POW!"</span></span>]</span>
<span class="function">ghci</span><span class="atom">&gt;</span> map <span class="paren1">(<span class="code">replicate 3</span>)</span> <span class="paren1">[<span class="code">3<span class="keyword">..</span>6</span>]</span>
<span class="paren1">[<span class="code"><span class="paren2">[<span class="code">3,3,3</span>]</span><span class="paren2">[<span class="code">4,4,4</span>]</span><span class="paren2">[<span class="code">5,5,5</span>]</span><span class="paren2">[<span class="code">6,6,6</span>]</span></span>]</span>
<span class="function">ghci</span><span class="atom">&gt;</span> map <span class="paren1">(<span class="code">map <span class="paren2">(<span class="code"><span class="atom">^</span>2</span>)</span></span>)</span> <span class="paren1">[<span class="code"><span class="paren2">[<span class="code">1,2</span>]</span>,<span class="paren2">[<span class="code">3,4,5,6</span>]</span>,<span class="paren2">[<span class="code">7,8</span>]</span></span>]</span>
<span class="paren1">[<span class="code"><span class="paren2">[<span class="code">1,4</span>]</span>,<span class="paren2">[<span class="code">9,16,25,36</span>]</span>,<span class="paren2">[<span class="code">49,64</span>]</span></span>]</span>
<span class="function">ghci</span><span class="atom">&gt;</span> map fst <span class="paren1">[<span class="code"><span class="paren2">(<span class="code">1,2</span>)</span>,<span class="paren2">(<span class="code">3,5</span>)</span>,<span class="paren2">(<span class="code">6,3</span>)</span>,<span class="paren2">(<span class="code">2,6</span>)</span>,<span class="paren2">(<span class="code">2,5</span>)</span></span>]</span>
<span class="paren1">[<span class="code">1,3,6,2,2</span>]</span></span></code></pre>

<p>Haskellの<code>map</code>は通常Common Lispの<code>MAPCAR</code>に相当する。</p>

<pre><code><span class="code">cl-user&gt; <span class="paren1">(<span class="code">mapcar #`<span class="paren2">(<span class="code">% '+ 3</span>)</span>'<span class="paren2">(<span class="code">1 5 1 3 6</span>)</span></span>)</span>
<span class="paren1">(<span class="code">4 8 4 6 9</span>)</span>
cl-user&gt; <span class="paren1">(<span class="code">mapcar #`<span class="paren2">(<span class="code">% 'uiop:strcat _ <span class="string">"!"</span></span>)</span>'<span class="paren2">(<span class="code"><span class="string">"BIFF"</span> <span class="string">"BANG"</span> <span class="string">"POW"</span></span>)</span></span>)</span>
<span class="paren1">(<span class="code"><span class="string">"BIFF!"</span> <span class="string">"BANG!"</span> <span class="string">"POW!"</span></span>)</span>
cl-user&gt; <span class="paren1">(<span class="code">mapcar #`<span class="paren2">(<span class="code">% 'mapcar #`<span class="paren3">(<span class="code">% 'expt _ 2</span>)</span></span>)</span>'<span class="paren2">(<span class="code"><span class="paren3">(<span class="code">1 2</span>)</span><span class="paren3">(<span class="code">3 4 5 6</span>)</span><span class="paren3">(<span class="code">7 8</span>)</span></span>)</span></span>)</span>
<span class="paren1">(<span class="code"><span class="paren2">(<span class="code">1 4</span>)</span><span class="paren2">(<span class="code">9 16 25 36</span>)</span><span class="paren2">(<span class="code">49 64</span>)</span></span>)</span>
cl-user&gt; <span class="paren1">(<span class="code">mapcar #'car '<span class="paren2">(<span class="code"><span class="paren3">(<span class="code">1 2</span>)</span><span class="paren3">(<span class="code">3 5</span>)</span><span class="paren3">(<span class="code">6 3</span>)</span><span class="paren3">(<span class="code">2 6</span>)</span><span class="paren3">(<span class="code">2 5</span>)</span></span>)</span></span>)</span>
<span class="paren1">(<span class="code">1 3 6 2 2</span>)</span></span></code></pre>

<h3>filter</h3>

<pre><code><span class="code"><span class="function">filter</span> <span class="keyword">::</span> <span class="paren1">(<span class="code">a <span class="keyword">-&gt;</span> <span class="variable">Bool</span></span>)</span> <span class="keyword">-&gt;</span> <span class="paren1">[<span class="code">a</span>]</span> <span class="keyword">-&gt;</span> <span class="paren1">[<span class="code">a</span>]</span>
<span class="function">filter</span> _ <span class="paren1">[<span class="code"></span>]</span> <span class="keyword">=</span> <span class="paren1">[<span class="code"></span>]</span>
<span class="function">filter</span> p <span class="paren1">(<span class="code">x<span class="variable">:</span>xs</span>)</span>
&nbsp;   <span class="keyword">|</span> p x       <span class="keyword">=</span> x <span class="variable">:</span> filter p xs
&nbsp;   <span class="keyword">|</span> otherwise <span class="keyword">=</span> filter p xs

<span class="function">ghci</span><span class="atom">&gt;</span> filter <span class="paren1">(<span class="code"><span class="atom">&gt;</span>3</span>)</span> <span class="paren1">[<span class="code">1,5,3,2,1,6,4,3,2,1</span>]</span>
<span class="paren1">[<span class="code">5,6,4</span>]</span>
<span class="function">ghci</span><span class="atom">&gt;</span> filter <span class="paren1">(<span class="code"><span class="atom">==</span>3</span>)</span> <span class="paren1">[<span class="code">1,2,3,4,5</span>]</span>
<span class="paren1">[<span class="code">3</span>]</span>
<span class="function">ghci</span><span class="atom">&gt;</span> filter even <span class="paren1">[<span class="code">1<span class="keyword">..</span>10</span>]</span>
<span class="paren1">[<span class="code">2,4,6,8,10</span>]</span>
<span class="function">ghci</span><span class="atom">&gt;</span> <span class="keyword">let</span> notNull x <span class="keyword">=</span> not <span class="paren1">(<span class="code">null x</span>)</span> <span class="keyword">in</span> filter notNull <span class="paren1">[<span class="code"><span class="paren2">[<span class="code">1,2,3</span>]</span>,<span class="paren2">[<span class="code"></span>]</span>,<span class="paren2">[<span class="code">3,4,5</span>]</span>,<span class="paren2">[<span class="code">2,2</span>]</span>,<span class="paren2">[<span class="code"></span>]</span>,<span class="paren2">[<span class="code"></span>]</span>,<span class="paren2">[<span class="code"></span>]</span></span>]</span>
<span class="paren1">[<span class="code"><span class="paren2">[<span class="code">1,2,3</span>]</span>,<span class="paren2">[<span class="code">3,4,5</span>]</span>,<span class="paren2">[<span class="code">2,2</span>]</span></span>]</span>
<span class="function">ghci</span><span class="atom">&gt;</span> filter <span class="paren1">(<span class="code"><span class="atom">`elm`</span> <span class="paren2">[<span class="code"><span class="character">'a'</span><span class="keyword">..</span><span class="character">'z'</span></span>]</span></span>)</span> <span class="string">"u LaUgH aT mE BeCaUsE I aM diFfeRent"</span>
<span class="string">"uagameasadifeent"</span>
<span class="function">ghci</span><span class="atom">&gt;</span> filter <span class="paren1">(<span class="code"><span class="atom">`elm`</span> <span class="paren2">[<span class="code"><span class="character">'A'</span><span class="keyword">..</span><span class="character">'Z'</span></span>]</span></span>)</span> <span class="string">"i LAuGh at you bEcause u R all the same"</span>
<span class="string">"LAGER"</span></span></code></pre>

<p>Haskellの<code>filter</code>はCommon Lispの<code>REMOVE-IF-NOT</code>に相当する。</p>

<pre><code><span class="code">cl-user&gt; <span class="paren1">(<span class="code">remove-if-not #`<span class="paren2">(<span class="code">% '&gt; _ 3</span>)</span>'<span class="paren2">(<span class="code">1 5 3 2 1 6 4 3 2 1</span>)</span></span>)</span>
<span class="paren1">(<span class="code">5 6 4</span>)</span>
cl-user&gt; <span class="paren1">(<span class="code">remove-if-not #`<span class="paren2">(<span class="code">% '= 3</span>)</span> '<span class="paren2">(<span class="code">1 2 3 4 5</span>)</span></span>)</span>
<span class="paren1">(<span class="code">3</span>)</span>
cl-user&gt; <span class="paren1">(<span class="code">remove-if #'null '<span class="paren2">(<span class="code"><span class="paren3">(<span class="code">1 2 3</span>)</span><span class="paren3">(<span class="code"></span>)</span><span class="paren3">(<span class="code">3 4 5</span>)</span><span class="paren3">(<span class="code">2 2</span>)</span><span class="paren3">(<span class="code"></span>)</span><span class="paren3">(<span class="code"></span>)</span><span class="paren3">(<span class="code"></span>)</span></span>)</span></span>)</span>
<span class="paren1">(<span class="code"><span class="paren2">(<span class="code">1 2 3</span>)</span><span class="paren2">(<span class="code">3 4 5</span>)</span><span class="paren2">(<span class="code">2 2</span>)</span></span>)</span>
cl-user&gt; <span class="paren1">(<span class="code">remove-if-not #'lower-case-p <span class="string">"u LaUgH aT mE BeCaUsE I aM diFfeRent"</span></span>)</span>
"uagameasadifeent"
cl-user&gt; <span class="paren1">(<span class="code">remove-if-not #'upper-case-p <span class="string">"i LAuGh at you bEcause u R all the same"</span></span>)</span>
"LAGER"</span></code></pre>

<pre><code><span class="code"><span class="function">ghci</span><span class="atom">&gt;</span> filter <span class="paren1">(<span class="code"><span class="atom">&lt;</span>15</span>)</span> <span class="paren1">(<span class="code">filter even <span class="paren2">[<span class="code">1<span class="keyword">..</span>20</span>]</span></span>)</span>
<span class="paren1">[<span class="code">2,4,6,8,10,12,14</span>]</span>
<span class="function">ghci</span><span class="atom">&gt;</span> <span class="paren1">[<span class="code">x <span class="keyword">|</span> x <span class="keyword">&lt;-</span> <span class="paren2">[<span class="code">1<span class="keyword">..</span>20</span>]</span>, x <span class="atom">&lt;</span> 15, even x</span>]</span>
<span class="paren1">[<span class="code">2,4,6,8,10,12,14</span>]</span></span></code></pre>

<pre><code><span class="code">cl-user&gt; <span class="paren1">(<span class="code">remove-if-not #`<span class="paren2">(<span class="code">% '&lt; _ 15</span>)</span><span class="paren2">(<span class="code">remove-if-not #'evenp <span class="paren3">(<span class="code">incf-cl:range 1 20</span>)</span></span>)</span></span>)</span>
<span class="paren1">(<span class="code">2 4 6 8 10 12 14</span>)</span>
cl-user&gt; <span class="paren1">(<span class="code">incf-cl:lc x <span class="paren2">(<span class="code">incf-cl:&lt;- x<span class="paren3">(<span class="code">incf-cl:range 1 20</span>)</span></span>)</span><span class="paren2">(<span class="code">&lt; x 15</span>)</span><span class="paren2">(<span class="code">evenp x</span>)</span></span>)</span>
<span class="paren1">(<span class="code">2 4 6 8 10 12 14</span>)</span>
cl-user&gt; <span class="paren1">(<span class="code"><i><span class="symbol">loop</span></i> <span class="keyword">:for</span> i <span class="keyword">:upfrom</span> 1 <span class="keyword">:to</span> 20 <span class="keyword">:when</span> <span class="paren2">(<span class="code">and <span class="paren3">(<span class="code">&lt; i 15</span>)</span><span class="paren3">(<span class="code">evenp i</span>)</span></span>)</span> <span class="keyword">:collect</span> i</span>)</span>
<span class="paren1">(<span class="code">2 4 6 8 10 12 14</span>)</span></span></code></pre>

<p>なお、<code>REMOVE-IF-NOT</code>は新しいリストを作って返すので、上記のようにネストして使うとメモリ効率が悪い。
上記３つのコードの中では、余計な中間リストを作らない<code>LOOP</code>が最も効率が良い。</p>

<h3>extra examples about map and filter</h3>

<pre><code><span class="code"><span class="function">largestDivisible</span> <span class="keyword">::</span> <span class="variable">Integer</span>
<span class="function">largestDivisible</span> <span class="keyword">=</span> head <span class="paren1">(<span class="code">filter p <span class="paren2">[<span class="code">100000,99999<span class="keyword">..</span></span>]</span></span>)</span>
&nbsp;   <span class="keyword">where</span> p x <span class="keyword">=</span> x <span class="atom">`mod`</span> 3829 <span class="atom">==</span> 0</span></code></pre>

<pre><code><span class="code"><span class="paren1">(<span class="code">declaim<span class="paren2">(<span class="code">ftype<span class="paren3">(<span class="code"><i><span class="symbol">function</span></i><span class="paren4">(<span class="code"></span>)</span>Integer</span>)</span>largest-divisible</span>)</span></span>)</span>
<span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> largest-divisible<span class="paren2">(<span class="code"></span>)</span>
  <span class="paren2">(<span class="code"><span class="paren3">(<span class="code"><i><span class="symbol">lambda</span></i><span class="paren4">(<span class="code">p</span>)</span><span class="paren4">(<span class="code">car<span class="paren5">(<span class="code">remove-if-not p <span class="paren6">(<span class="code">alexandria:iota 100000 <span class="keyword">:start</span> 100000 <span class="keyword">:step</span> -1</span>)</span></span>)</span></span>)</span></span>)</span>
   <span class="paren3">(<span class="code"><i><span class="symbol">lambda</span></i><span class="paren4">(<span class="code">x</span>)</span><span class="paren4">(<span class="code">zerop<span class="paren5">(<span class="code">mod x 3829</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>
<span class="comment">;; or
</span><span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> largest-divisible<span class="paren2">(<span class="code"></span>)</span>
  <span class="paren2">(<span class="code"><i><span class="symbol">loop</span></i> <span class="keyword">:for</span> x <span class="keyword">:downfrom</span> 100000
        <span class="keyword">:when</span> <span class="paren3">(<span class="code">zerop<span class="paren4">(<span class="code">mod x 3829</span>)</span></span>)</span>
        <span class="keyword">:do</span><span class="paren3">(<span class="code">return x</span>)</span></span>)</span></span>)</span>
<span class="comment">;; or
</span><span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> largest-divisible<span class="paren2">(<span class="code"></span>)</span>
  <span class="paren2">(<span class="code">series:collect-first <span class="paren3">(<span class="code">series:choose-if <span class="paren4">(<span class="code"><i><span class="symbol">lambda</span></i><span class="paren5">(<span class="code">x</span>)</span><span class="paren5">(<span class="code">zerop<span class="paren6">(<span class="code">mod x 3829</span>)</span></span>)</span></span>)</span>
                                          <span class="paren4">(<span class="code">series:scan-range <span class="keyword">:from</span> 100000 <span class="keyword">:by</span> -1</span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<p>Common Lispは遅延評価を行わない言語のため、上記コードも<code>LOOP</code>の方が効率がよく望ましい。
筆記順をHaskellと同様にしつつ効率を求めるならSERIESが望ましい。</p>

<pre><code><span class="code"><span class="function">ghci</span><span class="atom">&gt;</span> takeWile <span class="paren1">(<span class="code"><span class="atom">/=</span><span class="character">' '</span></span>)</span> <span class="string">"elephants know how to party"</span>
<span class="string">"elephants"</span>
<span class="function">ghci</span><span class="atom">&gt;</span> sum <span class="paren1">(<span class="code">takeWhile <span class="paren2">(<span class="code"><span class="atom">&lt;</span>10000</span>)</span> <span class="paren2">(<span class="code">filter odd <span class="paren3">(<span class="code">map <span class="paren4">(<span class="code"><span class="atom">^</span>2</span>)</span> <span class="paren4">[<span class="code">1<span class="keyword">..</span></span>]</span></span>)</span></span>)</span></span>)</span>
<span class="function">166650</span>
<span class="function">ghci</span><span class="atom">&gt;</span> sum <span class="paren1">(<span class="code">takeWhile <span class="paren2">(<span class="code"><span class="atom">&lt;</span>10000</span>)</span> <span class="paren2">[<span class="code">m <span class="keyword">|</span> m <span class="keyword">&lt;-</span> <span class="paren3">[<span class="code">n<span class="atom">^</span>2 <span class="keyword">|</span> n <span class="keyword">&lt;-</span> <span class="paren4">[<span class="code">1<span class="keyword">..</span></span>]</span></span>]</span>, odd m</span>]</span></span>)</span>
<span class="function">166650</span></span></code></pre>

<p>Common LispにHaskellの<code>takeWhile</code>相当の関数はない。
素のCommon Lispで書くなら以下のようになる。</p>

<pre><code><span class="code">cl-user&gt; <span class="paren1">(<span class="code"><i><span class="symbol">let</span></i><span class="paren2">(<span class="code"><span class="paren3">(<span class="code">string <span class="string">"elephants know how to party"</span></span>)</span></span>)</span>
           <span class="paren2">(<span class="code">subseq string 0 <span class="paren3">(<span class="code">position <span class="character">#\space</span> string</span>)</span></span>)</span></span>)</span>
"elephants"
cl-user&gt; <span class="paren1">(<span class="code"><i><span class="symbol">loop</span></i> <span class="keyword">:for</span> i <span class="keyword">:upfrom</span> 0
               <span class="keyword">:for</span> j = <span class="paren2">(<span class="code">expt i 2</span>)</span>
               <span class="keyword">:while</span> <span class="paren2">(<span class="code">&lt; j 10000</span>)</span>
               <span class="keyword">:when</span> <span class="paren2">(<span class="code">oddp j</span>)</span>
               <span class="keyword">:sum</span> j</span>)</span>
166650</span></code></pre>

<p>Seriesを使うなら以下のようになる。</p>

<pre><code><span class="code">cl-user&gt; <span class="paren1">(<span class="code">series:collect-sum
           <span class="paren2">(<span class="code">series:until-if <span class="paren3">(<span class="code">complement #`<span class="paren4">(<span class="code">% '&lt; _ 10000</span>)</span></span>)</span>
                            <span class="paren3">(<span class="code">series:choose-if #'oddp
                                              <span class="paren4">(<span class="code">series:map-fn 'integer
                                                             #`<span class="paren5">(<span class="code">% 'expt _ 2</span>)</span>
                                                             <span class="paren5">(<span class="code">series:scan-range <span class="keyword">:from</span> 0</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>
166650</span></code></pre>

<p>また、INCF-CLとSERAPEUMは各々<code>TAKE-WHILE</code>を提供している。
なお、INCF-CLの方はリストにしか使えない。
（METHODで実装されているので拡張は簡単だろうが、自分で書かなくてはならない。）</p>

<pre><code><span class="code"><span class="function">chain</span> <span class="keyword">::</span> <span class="variable">Integer</span> <span class="keyword">-&gt;</span> <span class="paren1">[<span class="code"><span class="variable">Integer</span></span>]</span>
<span class="function">chain</span> 1 <span class="keyword">=</span> <span class="paren1">[<span class="code">1</span>]</span>
<span class="function">chain</span> n
&nbsp;   <span class="keyword">|</span> even n <span class="keyword">=</span> n <span class="variable">:</span> chain <span class="paren1">(<span class="code">n <span class="atom">`div`</span>2</span>)</span>
&nbsp;   <span class="keyword">|</span> odd n  <span class="keyword">=</span> n <span class="variable">:</span> chain <span class="paren1">(<span class="code">n <span class="atom">*</span> 3 <span class="atom">+</span> 1</span>)</span>


<span class="function">numLongChains</span> <span class="keyword">::</span> <span class="variable">Int</span>
<span class="function">numLongChains</span> <span class="keyword">=</span> length <span class="paren1">(<span class="code">filter isLong <span class="paren2">(<span class="code">map chain <span class="paren3">[<span class="code">1<span class="keyword">..</span>100</span>]</span></span>)</span></span>)</span>
&nbsp;   <span class="keyword">where</span> isLong xs <span class="keyword">=</span> length xs <span class="atom">&gt;</span> 15</span></code></pre>

<pre><code><span class="code"><span class="paren1">(<span class="code">declaim<span class="paren2">(<span class="code">ftype<span class="paren3">(<span class="code"><i><span class="symbol">function</span></i><span class="paren4">(<span class="code">integer</span>)</span>list</span>)</span>chain</span>)</span></span>)</span>
<span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> chain<span class="paren2">(<span class="code">integer</span>)</span>
  <span class="paren2">(<span class="code"><i><span class="symbol">labels</span></i><span class="paren3">(<span class="code"><span class="paren4">(<span class="code">rec<span class="paren5">(<span class="code">n &amp;optional acc</span>)</span>
            <span class="paren5">(<span class="code"><i><span class="symbol">if</span></i><span class="paren6">(<span class="code">= 1 n</span>)</span>
              <span class="paren6">(<span class="code">nreconc acc <span class="paren1">(<span class="code">list 1</span>)</span></span>)</span>
              <span class="paren6">(<span class="code"><i><span class="symbol">if</span></i><span class="paren1">(<span class="code">evenp n</span>)</span>
                <span class="paren1">(<span class="code">rec <span class="paren2">(<span class="code">/ n 2</span>)</span><span class="paren2">(<span class="code">cons n acc</span>)</span></span>)</span>
                <span class="paren1">(<span class="code">rec <span class="paren2">(<span class="code">1+ <span class="paren3">(<span class="code">* 3 n</span>)</span></span>)</span><span class="paren2">(<span class="code">cons n acc</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>
    <span class="paren3">(<span class="code">rec integer</span>)</span></span>)</span></span>)</span>

<span class="paren1">(<span class="code">declaim<span class="paren2">(<span class="code">ftype<span class="paren3">(<span class="code"><i><span class="symbol">function</span></i><span class="paren4">(<span class="code"></span>)</span>integer</span>)</span>num-long-chains</span>)</span></span>)</span>
<span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> num-long-chains<span class="paren2">(<span class="code"></span>)</span>
  <span class="paren2">(<span class="code"><span class="paren3">(<span class="code"><i><span class="symbol">lambda</span></i><span class="paren4">(<span class="code">long-p</span>)</span>
    <span class="paren4">(<span class="code">length <span class="paren5">(<span class="code">delete-if-not long-p <span class="paren6">(<span class="code">mapcar #'chain <span class="paren1">(<span class="code">incf-cl:range 1 100</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>
   <span class="paren3">(<span class="code"><i><span class="symbol">lambda</span></i><span class="paren4">(<span class="code">xs</span>)</span><span class="paren4">(<span class="code">&gt; <span class="paren5">(<span class="code">length xs</span>)</span>15</span>)</span></span>)</span></span>)</span></span>)</span>
<span class="comment">;; or
</span><span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> num-long-chains<span class="paren2">(<span class="code"></span>)</span>
  <span class="paren2">(<span class="code"><i><span class="symbol">loop</span></i> <span class="keyword">:for</span> i <span class="keyword">:upfrom</span> 1 <span class="keyword">:to</span> 100
        <span class="keyword">:when</span> <span class="paren3">(<span class="code">&lt; 15 <span class="paren4">(<span class="code">length<span class="paren5">(<span class="code">chain i</span>)</span></span>)</span></span>)</span>
        <span class="keyword">:count</span> it</span>)</span></span>)</span></span></code></pre>

<p>本例もまた、余計な中間リストを作らない分<code>LOOP</code>の方が望ましい。</p>

<p>Seriesで書くなら以下の通り。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">series:collect-length<span class="paren2">(<span class="code">series:choose-if <span class="paren3">(<span class="code"><i><span class="symbol">lambda</span></i><span class="paren4">(<span class="code">l</span>)</span><span class="paren4">(<span class="code">&gt; <span class="paren5">(<span class="code">length l</span>)</span>15</span>)</span></span>)</span>
                                        <span class="paren3">(<span class="code">series:map-fn 'list #'chain
                                                       <span class="paren4">(<span class="code">series:scan-range <span class="keyword">:from</span> 1 <span class="keyword">:upto</span> 100</span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<h3>Applying some arguments to map</h3>

<pre><code><span class="code"><span class="function">ghci</span><span class="atom">&gt;</span> <span class="keyword">let</span> listOfFuns <span class="keyword">=</span> map <span class="paren1">(<span class="code"><span class="atom">*</span></span>)</span> <span class="paren1">[<span class="code">0<span class="keyword">..</span></span>]</span>
<span class="function">ghci</span><span class="atom">&gt;</span> <span class="paren1">(<span class="code">listOfFuns <span class="atom">!!</span> 4</span>)</span> 5
<span class="function">20</span></span></code></pre>

<p>遅延リストに依存したコードなのでSERIESを使わないと再現できない。</p>

<pre><code><span class="code">cl-user&gt; <span class="paren1">(<span class="code"><i><span class="symbol">defvar</span></i> <span class="special">*list-of-funs*</span> <span class="paren2">(<span class="code">series:map-fn '<i><span class="symbol">function</span></i> #`<span class="paren3">(<span class="code">% 'alexandria:curry '*</span>)</span>
                                               <span class="paren3">(<span class="code">series:scan-range <span class="keyword">:from</span> 0</span>)</span></span>)</span></span>)</span>
*LIST-OF-FUNS*
cl-user&gt; <span class="paren1">(<span class="code">funcall <span class="paren2">(<span class="code">series:collect-nth 4 <span class="special">*list-of-funs*</span></span>)</span>5</span>)</span>
20</span></code></pre>

<h3>lambda expression</h3>

<pre><code><span class="code"><span class="function">numLongChains</span> <span class="keyword">::</span> <span class="variable">Int</span>
<span class="function">numLongChains</span> <span class="keyword">=</span> length <span class="paren1">(<span class="code">filter <span class="paren2">(<span class="code"><span class="keyword">\</span>xs <span class="keyword">-&gt;</span> length xs <span class="atom">&gt;</span> 15</span>)</span>
&nbsp;                              <span class="paren2">(<span class="code">map chain <span class="paren3">[<span class="code">1<span class="keyword">..</span>100</span>]</span></span>)</span></span>)</span></span></code></pre>

<pre><code><span class="code"><span class="paren1">(<span class="code">declaim<span class="paren2">(<span class="code">ftype<span class="paren3">(<span class="code"><i><span class="symbol">function</span></i><span class="paren4">(<span class="code"></span>)</span>fixnum</span>)</span>num-long-chains</span>)</span></span>)</span>
<span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> num-long-chains<span class="paren2">(<span class="code"></span>)</span>
  <span class="paren2">(<span class="code">length<span class="paren3">(<span class="code">remove-if-not <span class="paren4">(<span class="code"><i><span class="symbol">lambda</span></i><span class="paren5">(<span class="code">xs</span>)</span><span class="paren5">(<span class="code">&gt; <span class="paren6">(<span class="code">length xs</span>)</span> 15</span>)</span></span>)</span>
                        <span class="paren4">(<span class="code">mapcar #'chain <span class="paren5">(<span class="code">incf-cl:range 1 100</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<p>余計な中間リストが出来る分、非効率的である。
前々節の再掲となるが、 Seriesで書くなら以下の通り。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">series:collect-length<span class="paren2">(<span class="code">series:choose-if <span class="paren3">(<span class="code"><i><span class="symbol">lambda</span></i><span class="paren4">(<span class="code">xs</span>)</span><span class="paren4">(<span class="code">&gt; <span class="paren5">(<span class="code">length xs</span>)</span>15</span>)</span></span>)</span>
                                        <span class="paren3">(<span class="code">series:map-fn 'list #'chain
                                                       <span class="paren4">(<span class="code">series:scan-range <span class="keyword">:from</span> 1 <span class="keyword">:upto</span> 100</span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<pre><code><span class="code"><span class="function">ghci</span><span class="atom">&gt;</span> zipWith <span class="paren1">(<span class="code"><span class="keyword">\</span>a b <span class="keyword">-&gt;</span> <span class="paren2">(<span class="code">a <span class="atom">*</span> 30 <span class="atom">+</span> 3</span>)</span> <span class="atom">/</span> b</span>)</span> <span class="paren1">[<span class="code">5,4,3,2,1</span>]</span> <span class="paren1">[<span class="code">1,2,3,4,5</span>]</span>
<span class="paren1">[<span class="code">153<span class="atom">.</span>0,61<span class="atom">.</span>5,31<span class="atom">.</span>0,15<span class="atom">.</span>75,6<span class="atom">.</span>6</span>]</span>
<span class="function">ghci</span><span class="atom">&gt;</span> map <span class="paren1">(<span class="code"><span class="keyword">\</span><span class="paren2">(<span class="code">a,b</span>)</span> <span class="keyword">-&gt;</span> a <span class="atom">+</span> b</span>)</span> <span class="paren1">[<span class="code"><span class="paren2">(<span class="code">1,2</span>)</span>,<span class="paren2">(<span class="code">3,5</span>)</span>,<span class="paren2">(<span class="code">6,3</span>)</span>,<span class="paren2">(<span class="code">2,6</span>)</span>,<span class="paren2">(<span class="code">2,5</span>)</span></span>]</span>
<span class="paren1">[<span class="code">3,8,9,8,7</span>]</span></span></code></pre>

<pre><code><span class="code">cl-user&gt; <span class="paren1">(<span class="code">mapcar <span class="paren2">(<span class="code"><i><span class="symbol">lambda</span></i><span class="paren3">(<span class="code">a b</span>)</span><span class="paren3">(<span class="code">float<span class="paren4">(<span class="code">infix-math:$ <span class="paren5">(<span class="code">a * 30 + 3</span>)</span> / b</span>)</span></span>)</span></span>)</span> '<span class="paren2">(<span class="code">5 4 3 2 1</span>)</span>'<span class="paren2">(<span class="code">1 2 3 4 5</span>)</span></span>)</span>
<span class="paren1">(<span class="code">153.0 61.5 31.0 15.75 6.6</span>)</span>
cl-user&gt; <span class="paren1">(<span class="code">mapcar <span class="paren2">(<span class="code">trivia:lambda-match<span class="paren3">(<span class="code"><span class="paren4">(<span class="code">cons a b</span>)</span><span class="paren4">(<span class="code">+ a b</span>)</span></span>)</span></span>)</span> '<span class="paren2">(<span class="code"><span class="paren3">(<span class="code">1 . 2</span>)</span><span class="paren3">(<span class="code">3 . 5</span>)</span><span class="paren3">(<span class="code">6 . 3</span>)</span><span class="paren3">(<span class="code">2 . 6</span>)</span><span class="paren3">(<span class="code">2 . 5</span>)</span></span>)</span></span>)</span>
<span class="paren1">(<span class="code">3 8 9 8 7</span>)</span></span></code></pre>

<p>引数がドット対でなくプロパリストなら<code>APPLY</code>を使って以下のように書ける。</p>

<pre><code><span class="code">cl-user&gt; <span class="paren1">(<span class="code">mapcar #`<span class="paren2">(<span class="code">% 'apply '+</span>)</span> '<span class="paren2">(<span class="code"><span class="paren3">(<span class="code">1 2</span>)</span><span class="paren3">(<span class="code">3 5</span>)</span><span class="paren3">(<span class="code">6 3</span>)</span><span class="paren3">(<span class="code">2 6</span>)</span><span class="paren3">(<span class="code">2 5</span>)</span></span>)</span></span>)</span>
<span class="paren1">(<span class="code">3 8 9 8 7</span>)</span></span></code></pre>

<h2>5.5</h2>

<h3>foldl</h3>

<pre><code><span class="code"><span class="function">ghci</span><span class="atom">&gt;</span> <span class="variable">:</span>t foldl
<span class="function">foldl</span> <span class="keyword">::</span> <span class="paren1">(<span class="code">a <span class="keyword">-&gt;</span> b <span class="keyword">-&gt;</span> a</span>)</span> <span class="keyword">-&gt;</span> a <span class="keyword">-&gt;</span> <span class="paren1">[<span class="code">b</span>]</span> <span class="keyword">-&gt;</span> a

<span class="function">sum'</span> <span class="keyword">::</span> <span class="paren1">(<span class="code"><span class="variable">Num</span> a</span>)</span> <span class="atom">=&gt;</span> <span class="paren1">[<span class="code">a</span>]</span> <span class="keyword">-&gt;</span> a
<span class="function">sum'</span> xs <span class="keyword">=</span> foldl <span class="paren1">(<span class="code"><span class="keyword">\</span>acc x <span class="keyword">-&gt;</span> acc <span class="atom">+</span> x</span>)</span> 0 xs

;; or
<span class="function">sum'</span> <span class="keyword">=</span> foldl <span class="paren1">(<span class="code"><span class="atom">+</span></span>)</span> 0

<span class="function">ghci</span><span class="atom">&gt;</span> sum' <span class="paren1">[<span class="code">3,5,2,1</span>]</span>
<span class="function">11</span></span></code></pre>

<p>Haskellの<code>foldl</code>はCommon Lispでは<code>REDUCE</code>に相当する。
なお、Common Lispに於いて<code>REDUCE</code>は、必ずしも効率の良いオペレータではないので、代替案も同時に記しておく。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">reduce #'+ '<span class="paren2">(<span class="code">3 5 2 1</span>)</span></span>)</span>
11
<span class="comment">;; or
</span><span class="paren1">(<span class="code">apply #'+ '<span class="paren2">(<span class="code">3 5 2 1</span>)</span></span>)</span></span></code></pre>

<h3>foldr</h3>

<p>Haskellの<code>foldr</code>はCommon Lispでは<code>REDUCE</code>に<code>:FROM-END</code>キーワード引数を渡して再現することとなる。</p>

<pre><code><span class="code"><span class="comment">;; foldL
</span><span class="paren1">(<span class="code">reduce #'cons '<span class="paren2">(<span class="code">1 2 3 4 5</span>)</span> <span class="keyword">:initial-value</span> 9</span>)</span>
<span class="paren1">(<span class="code"><span class="paren2">(<span class="code"><span class="paren3">(<span class="code"><span class="paren4">(<span class="code">9 . 1</span>)</span> . 2</span>)</span> . 3</span>)</span> . 4 . 5</span>)</span>
1&gt; <span class="paren1">(<span class="code">cons 9 1</span>)</span>
2&gt; <span class="paren1">(<span class="code">cons * 2</span>)</span>
3&gt; <span class="paren1">(<span class="code">cons * 3</span>)</span>
4&gt; <span class="paren1">(<span class="code">cons * 4</span>)</span>
5&gt; <span class="paren1">(<span class="code">cons * 5</span>)</span>

<span class="comment">;; foldR
</span><span class="paren1">(<span class="code">reduce #'cons '<span class="paren2">(<span class="code">1 2 3 4 5</span>)</span> <span class="keyword">:initial-value</span> 9 <span class="keyword">:from-end</span> t</span>)</span>
<span class="paren1">(<span class="code">1 2 3 4 5 . 9</span>)</span>
1&gt; <span class="paren1">(<span class="code">cons 5 9</span>)</span>
2&gt; <span class="paren1">(<span class="code">cons 4 *</span>)</span>
3&gt; <span class="paren1">(<span class="code">cons 3 *</span>)</span>
4&gt; <span class="paren1">(<span class="code">cons 2 *</span>)</span>
5&gt; <span class="paren1">(<span class="code">cons 1 *</span>)</span>
<span class="comment">;; or
</span><span class="paren1">(<span class="code"><i><span class="symbol">multiple-value-call</span></i> #'list* <span class="paren2">(<span class="code">values-list '<span class="paren3">(<span class="code">1 2 3 4 5</span>)</span></span>)</span> 9</span>)</span></span></code></pre>

<h3>examples</h3>

<pre><code><span class="code"><span class="function">reverse'</span> <span class="keyword">::</span> <span class="paren1">[<span class="code">a</span>]</span> <span class="keyword">-&gt;</span> <span class="paren1">[<span class="code">a</span>]</span>
<span class="function">reverse'</span> <span class="keyword">=</span> foldl <span class="paren1">(<span class="code"><span class="keyword">\</span>acc x <span class="keyword">-&gt;</span> x <span class="variable">:</span> acc</span>)</span> <span class="paren1">[<span class="code"></span>]</span></span></code></pre>

<pre><code><span class="code"><span class="paren1">(<span class="code">declaim<span class="paren2">(<span class="code">ftype<span class="paren3">(<span class="code"><i><span class="symbol">function</span></i><span class="paren4">(<span class="code">list</span>)</span>list</span>)</span>reverse%</span>)</span></span>)</span>
<span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> reverse%<span class="paren2">(<span class="code">list</span>)</span>
  <span class="paren2">(<span class="code">reduce <span class="paren3">(<span class="code"><i><span class="symbol">lambda</span></i><span class="paren4">(<span class="code">x y</span>)</span><span class="paren4">(<span class="code">cons y x</span>)</span></span>)</span>list <span class="keyword">:initial-value</span> nil</span>)</span></span>)</span></span></code></pre>

<pre><code><span class="code"><span class="function">product'</span> <span class="keyword">::</span> <span class="paren1">(<span class="code"><span class="variable">Num</span> a</span>)</span> <span class="atom">=&gt;</span> <span class="paren1">[<span class="code">a</span>]</span> <span class="keyword">-&gt;</span> a
<span class="function">product'</span> <span class="keyword">=</span> foldl <span class="paren1">(<span class="code"><span class="atom">*</span></span>)</span> 1</span></code></pre>

<pre><code><span class="code"><span class="paren1">(<span class="code">declaim<span class="paren2">(<span class="code">ftype<span class="paren3">(<span class="code"><i><span class="symbol">function</span></i><span class="paren4">(<span class="code">list</span>)</span>integer</span>)</span>product</span>)</span></span>)</span>
<span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> product <span class="paren2">(<span class="code">list</span>)</span>
  <span class="paren2">(<span class="code">reduce #'* list</span>)</span></span>)</span>
<span class="comment">;; or
</span><span class="paren1">(<span class="code">apply #'* list</span>)</span></span></code></pre>

<pre><code><span class="code"><span class="function">filter'</span> <span class="keyword">::</span> <span class="paren1">(<span class="code">a <span class="keyword">-&gt;</span> <span class="variable">Bool</span></span>)</span> <span class="keyword">-&gt;</span> <span class="paren1">[<span class="code">a</span>]</span> <span class="keyword">-&gt;</span> <span class="paren1">[<span class="code">a</span>]</span>
<span class="function">filter'</span> p <span class="keyword">=</span> foldr <span class="paren1">(<span class="code"><span class="keyword">\</span>x acc <span class="keyword">-&gt;</span> <span class="keyword">if</span> p x <span class="keyword">then</span> x <span class="variable">:</span> acc <span class="keyword">else</span> acc</span>)</span> <span class="paren1">[<span class="code"></span>]</span></span></code></pre>

<pre><code><span class="code"><span class="paren1">(<span class="code">declaim<span class="paren2">(<span class="code">ftype<span class="paren3">(<span class="code"><i><span class="symbol">function</span></i><span class="paren4">(<span class="code"><i><span class="symbol">function</span></i> list</span>)</span>list</span>)</span>filter</span>)</span></span>)</span>
<span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> filter<span class="paren2">(<span class="code">pred list</span>)</span>
  <span class="paren2">(<span class="code">reduce <span class="paren3">(<span class="code"><i><span class="symbol">lambda</span></i><span class="paren4">(<span class="code">x acc</span>)</span>
            <span class="paren4">(<span class="code"><i><span class="symbol">if</span></i><span class="paren5">(<span class="code">funcall pred x</span>)</span>
              <span class="paren5">(<span class="code">cons x acc</span>)</span>
              acc</span>)</span></span>)</span>
          list
          <span class="keyword">:initial-value</span> nil <span class="keyword">:from-end</span> t</span>)</span></span>)</span>
<span class="comment">;; or
</span><span class="paren1">(<span class="code">remove-if-not pred list</span>)</span></span></code></pre>

<pre><code><span class="code"><span class="function">last'</span> <span class="keyword">::</span> <span class="paren1">[<span class="code">a</span>]</span> <span class="keyword">-&gt;</span> a
<span class="function">last'</span> <span class="keyword">=</span> foldl1 <span class="paren1">(<span class="code"><span class="keyword">\</span>_ x <span class="keyword">-&gt;</span> x</span>)</span></span></code></pre>

<pre><code><span class="code"><span class="paren1">(<span class="code">declaim<span class="paren2">(<span class="code">ftype<span class="paren3">(<span class="code"><i><span class="symbol">function</span></i><span class="paren4">(<span class="code">list</span>)</span>t</span>)</span>last1</span>)</span></span>)</span>
<span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> last1<span class="paren2">(<span class="code">list</span>)</span>
  <span class="paren2">(<span class="code">reduce <span class="paren3">(<span class="code"><i><span class="symbol">lambda</span></i><span class="paren4">(<span class="code">_ x</span>)</span><span class="paren4">(<span class="code">declare<span class="paren5">(<span class="code">ignore _</span>)</span></span>)</span>x</span>)</span>list</span>)</span></span>)</span>
<span class="comment">;; or
</span><span class="paren1">(<span class="code">alexandria:lastcar list</span>)</span></span></code></pre>

<h3>another view.</h3>

<h3>reducing infinite list.</h3>

<pre><code><span class="code"><span class="function">and'</span> <span class="keyword">::</span> <span class="paren1">[<span class="code"><span class="variable">Bool</span></span>]</span> <span class="keyword">-&gt;</span> <span class="variable">Bool</span>
<span class="function">and'</span> xs <span class="keyword">=</span> foldr <span class="paren1">(<span class="code"><span class="atom">&amp;&amp;</span></span>)</span> <span class="variable">True</span> xs</span></code></pre>

<pre><code><span class="code"><span class="paren1">(<span class="code">declaim<span class="paren2">(<span class="code">ftype<span class="paren3">(<span class="code"><i><span class="symbol">function</span></i><span class="paren4">(<span class="code">list</span>)</span>boolean</span>)</span>and%</span>)</span></span>)</span>
<span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> and%<span class="paren2">(<span class="code">list</span>)</span>
  <span class="paren2">(<span class="code">reduce <span class="paren3">(<span class="code"><i><span class="symbol">lambda</span></i><span class="paren4">(<span class="code">x y</span>)</span><span class="paren4">(<span class="code">and x y</span>)</span></span>)</span>list</span>)</span></span>)</span>
<span class="comment">;; or
</span><span class="paren1">(<span class="code">every #'identity list</span>)</span></span></code></pre>

<p>Common Lispは遅延リストをサポートしていないので、<code>REDUCE</code>を使ったバージョンは<code>NIL</code>に出会っても走査は止まらない。
リストを最後まで舐めつくしてしまう。</p>

<p>Common Lispにはまさにそのためのオペレータ<code>EVERY</code>が提供されている。
なお、少々分かりづらいと思うので、念の為説明しておくが、上記<code>IDENTITY</code>は<code>(lambda(x)(not(null x)))</code>と等価である。
なんなら以下のように書いてもよい。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">notany #'null list</span>)</span></span></code></pre>

<p>個人的には<code>NOTANY</code>と<code>NOTEVERY</code>は分かりづらいと思っているので、<code>SOME</code>、<code>EVERY</code>の方が好きだ。</p>

<p>なお、SERIESには<code>COLLECT-AND</code>があるので、無限リストが必要になった場合はそれで対応可能である。</p>

<h3>scan</h3>

<pre><code><span class="code"><span class="function">ghci</span><span class="atom">&gt;</span> scanl <span class="paren1">(<span class="code"><span class="atom">+</span></span>)</span> 0 <span class="paren1">[<span class="code">3,5,2,1</span>]</span>
<span class="paren1">[<span class="code">0,3,8,10,11</span>]</span>
<span class="function">ghci</span><span class="atom">&gt;</span> scanr <span class="paren1">(<span class="code"><span class="atom">+</span></span>)</span> 0 <span class="paren1">[<span class="code">3,5,2,1</span>]</span>
<span class="paren1">[<span class="code">11,8,3,1,0</span>]</span>
<span class="function">ghci</span><span class="atom">&gt;</span> scanl1 <span class="paren1">(<span class="code"><span class="keyword">\</span>acc x <span class="keyword">-&gt;</span> <span class="keyword">if</span> x <span class="atom">&gt;</span> acc <span class="keyword">then</span> x <span class="keyword">else</span> acc</span>)</span> <span class="paren1">[<span class="code">3,4,5,3,7,9,2,1</span>]</span>
<span class="paren1">[<span class="code">3,4,5,5,7,9,9,9</span>]</span>
<span class="function">ghci</span><span class="atom">&gt;</span> scanl <span class="paren1">(<span class="code">flip<span class="paren2">(<span class="code"><span class="variable">:</span></span>)</span></span>)</span> <span class="paren1">[<span class="code"></span>]</span> <span class="paren1">[<span class="code">3,2,1</span>]</span>
<span class="paren1">[<span class="code"><span class="paren2">[<span class="code"></span>]</span>,<span class="paren2">[<span class="code">3</span>]</span>,<span class="paren2">[<span class="code">2,3</span>]</span>,<span class="paren2">[<span class="code">1,2,3</span>]</span></span>]</span></span></code></pre>

<p>Common Lispに上記<code>scan</code>のファミリーは存在しない。
serapeumが<code>SCAN</code>を、INCF-CLが<code>SCAN*</code>を提供している。</p>

<pre><code><span class="code">cl-user&gt; <span class="paren1">(<span class="code">serapeum:scan #'+ '<span class="paren2">(<span class="code">3 5 2 1</span>)</span> <span class="keyword">:initial-value</span> 0</span>)</span>
<span class="paren1">(<span class="code">0 3 8 10 11</span>)</span>
cl-user&gt; <span class="paren1">(<span class="code">incf-cl:scan* #'+ '<span class="paren2">(<span class="code">3 5 2 1</span>)</span> <span class="keyword">:initial-value</span> 0</span>)</span>
<span class="paren1">(<span class="code">0 3 8 10 11</span>)</span></span></code></pre>

<p>Haskellの<code>scanr</code>はINCF-CLのみが対応可能となっている。</p>

<pre><code><span class="code">cl-user&gt; <span class="paren1">(<span class="code">incf-cl:scan* #'+ '<span class="paren2">(<span class="code">3 5 2 1</span>)</span> <span class="keyword">:initial-value</span> 0 <span class="keyword">:from-end</span> T</span>)</span>
<span class="paren1">(<span class="code">11 8 3 1 0</span>)</span></span></code></pre>

<p>Haskellの<code>scanl1</code>は単に<code>:INITIAL-VALUE</code>を渡さなければ良い。</p>

<pre><code><span class="code">cl-user&gt; <span class="paren1">(<span class="code">serapeum:scan <span class="paren2">(<span class="code"><i><span class="symbol">lambda</span></i><span class="paren3">(<span class="code">acc x</span>)</span><span class="paren3">(<span class="code"><i><span class="symbol">if</span></i><span class="paren4">(<span class="code">&lt; acc x</span>)</span>x acc</span>)</span></span>)</span>'<span class="paren2">(<span class="code">3 4 5 3 7 9 2 1</span>)</span></span>)</span>
<span class="paren1">(<span class="code">3 4 5 5 7 9 9 9</span>)</span>
cl-user&gt; <span class="paren1">(<span class="code">incf-cl:scan* <span class="paren2">(<span class="code"><i><span class="symbol">lambda</span></i><span class="paren3">(<span class="code">acc x</span>)</span><span class="paren3">(<span class="code"><i><span class="symbol">if</span></i><span class="paren4">(<span class="code">&lt; acc x</span>)</span>x acc</span>)</span></span>)</span>'<span class="paren2">(<span class="code">3 4 5 3 7 9 2 1</span>)</span></span>)</span>
<span class="paren1">(<span class="code">3 4 5 5 7 9 9 9</span>)</span></span></code></pre>

<p>serapeumの<code>SCAN</code>はhaskellの<code>scanl</code>とは異なる挙動をする。
（狙ってこのような挙動に敢えてしてある可能性があるので、ここではバグとは言わない。）</p>

<pre><code><span class="code">cl-user&gt; <span class="paren1">(<span class="code">serapeum:scan <span class="paren2">(<span class="code">incf-cl:flip #'cons</span>)</span> '<span class="paren2">(<span class="code">3 2 1</span>)</span> <span class="keyword">:initial-value</span> nil</span>)</span>
<span class="paren1">(<span class="code">NIL <span class="paren2">(<span class="code">NIL . 3</span>)</span> <span class="paren2">(<span class="code"><span class="paren3">(<span class="code">NIL . 3</span>)</span> . 2</span>)</span> <span class="paren2">(<span class="code"><span class="paren3">(<span class="code"><span class="paren4">(<span class="code">NIL . 3</span>)</span> . 2</span>)</span> . 1</span>)</span></span>)</span>
cl-user&gt; <span class="paren1">(<span class="code">incf-cl:scan* <span class="paren2">(<span class="code">incf-cl:flip #'cons</span>)</span> '<span class="paren2">(<span class="code">3 2 1</span>)</span> <span class="keyword">:initial-value</span> nil</span>)</span>
<span class="paren1">(<span class="code">NIL <span class="paren2">(<span class="code">3</span>)</span> <span class="paren2">(<span class="code">2 3</span>)</span> <span class="paren2">(<span class="code">1 2 3</span>)</span></span>)</span></span></code></pre>

<p>Serapeumの方はシーケンスに対応しているのが魅力となる。
リストにしか使わないのであればINCF-CLの方がよろしかろう。
なお、双方とも<code>:KEY</code>キーワード引数をサポートしている。</p>

<pre><code><span class="code"><span class="function">sqrtSums</span> <span class="keyword">::</span> <span class="variable">Int</span>
<span class="function">sqrtSums</span> <span class="keyword">=</span> length <span class="paren1">(<span class="code">takeWhile <span class="paren2">(<span class="code"><span class="atom">&lt;</span>1000</span>)</span><span class="paren2">(<span class="code">scanl1 <span class="paren3">(<span class="code"><span class="atom">+</span></span>)</span> <span class="paren3">(<span class="code">map sqrt <span class="paren4">[<span class="code">1<span class="keyword">..</span></span>]</span></span>)</span></span>)</span></span>)</span> <span class="atom">+</span> 1
<span class="function">ghci</span><span class="atom">&gt;</span> sqrtSums
<span class="function">131</span>
<span class="function">ghci</span><span class="atom">&gt;</span> sum <span class="paren1">(<span class="code">map sqrt <span class="paren2">[<span class="code">1<span class="keyword">..</span>131</span>]</span></span>)</span>
<span class="function">1005</span><span class="atom">.</span>0942035344083
<span class="function">ghci</span><span class="atom">&gt;</span> sum <span class="paren1">(<span class="code">map sqrt <span class="paren2">[<span class="code">1<span class="keyword">..</span>130</span>]</span></span>)</span>
<span class="function">993</span><span class="atom">.</span>6486803921487</span></code></pre>

<p>Common Lispは遅延リストをサポートしていないので、上記Haskellコードを直訳すると、中間リストが作られまくり効率が著しく悪くなる。
<code>LOOP</code>マクロで対応するのが望ましい。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">declaim<span class="paren2">(<span class="code">ftype<span class="paren3">(<span class="code"><i><span class="symbol">function</span></i><span class="paren4">(<span class="code"></span>)</span>integer</span>)</span>sqrt-sums</span>)</span></span>)</span>
<span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> sqrt-sums<span class="paren2">(<span class="code"></span>)</span>
 <span class="paren2">(<span class="code">1+ <span class="paren3">(<span class="code"><i><span class="symbol">loop</span></i> <span class="keyword">:for</span> i <span class="keyword">:upfrom</span> 1
           <span class="keyword">:sum</span> <span class="paren4">(<span class="code">sqrt i</span>)</span> <span class="keyword">:into</span> sums
           <span class="keyword">:while</span> <span class="paren4">(<span class="code">&lt; sums 1000</span>)</span>
           <span class="keyword">:count</span> sums</span>)</span></span>)</span></span>)</span>
cl-user&gt; <span class="paren1">(<span class="code">sqrt-sums</span>)</span>
131
cl-user&gt; <span class="paren1">(<span class="code"><i><span class="symbol">loop</span></i> <span class="keyword">:for</span> i <span class="keyword">:upfrom</span> 1 <span class="keyword">:to</span> 131 <span class="keyword">:sum</span> <span class="paren2">(<span class="code">sqrt i</span>)</span></span>)</span>
1005.0941
cl-user&gt; <span class="paren1">(<span class="code"><i><span class="symbol">loop</span></i> <span class="keyword">:for</span> i <span class="keyword">:upfrom</span> 1 <span class="keyword">:to</span> 130 <span class="keyword">:sum</span> <span class="paren2">(<span class="code">sqrt i</span>)</span></span>)</span>
993.6486</span></code></pre>

<h2>5.6</h2>

<pre><code><span class="code"><span class="function">ghci</span><span class="atom">&gt;</span> sum <span class="paren1">(<span class="code">filter <span class="paren2">(<span class="code"><span class="atom">&gt;</span> 10</span>)</span> <span class="paren2">(<span class="code">map <span class="paren3">(<span class="code"><span class="atom">*</span>2</span>)</span> <span class="paren3">[<span class="code">2<span class="keyword">..</span>10</span>]</span></span>)</span></span>)</span>
<span class="function">80</span>
<span class="function">ghci</span><span class="atom">&gt;</span> sum <span class="atom">$</span> filter <span class="paren1">(<span class="code"><span class="atom">&gt;</span> 10</span>)</span> <span class="paren1">(<span class="code">map <span class="paren2">(<span class="code"><span class="atom">*</span>2</span>)</span> <span class="paren2">[<span class="code">2<span class="keyword">..</span>10</span>]</span></span>)</span>
<span class="function">80</span>
<span class="function">ghci</span><span class="atom">&gt;</span> sum <span class="atom">$</span> filter <span class="paren1">(<span class="code"><span class="atom">&gt;</span> 10</span>)</span> <span class="atom">$</span> map <span class="paren1">(<span class="code"><span class="atom">*</span>2</span>)</span> <span class="paren1">[<span class="code">2<span class="keyword">..</span>10</span>]</span>
<span class="function">80</span>

<span class="function">ghci</span><span class="atom">&gt;</span> map <span class="paren1">(<span class="code"><span class="atom">$</span> 3</span>)</span> <span class="paren1">[<span class="code"><span class="paren2">(<span class="code">4<span class="atom">+</span></span>)</span>,<span class="paren2">(<span class="code">10<span class="atom">*</span></span>)</span>,<span class="paren2">(<span class="code"><span class="atom">^</span>2</span>)</span>, sqrt</span>]</span>
<span class="paren1">[<span class="code">7<span class="atom">.</span>0,30<span class="atom">.</span>0,9<span class="atom">.</span>0,1<span class="atom">.</span>7320508075688772</span>]</span></span></code></pre>

<pre><code><span class="code">cl-user&gt; <span class="paren1">(<span class="code">apply #'+ <span class="paren2">(<span class="code">remove-if-not #`<span class="paren3">(<span class="code">% '&gt; _ 10</span>)</span> <span class="paren3">(<span class="code">mapcar #`<span class="paren4">(<span class="code">% '* 2</span>)</span><span class="paren4">(<span class="code">incf-cl:range 2 10</span>)</span></span>)</span></span>)</span></span>)</span>
80
cl-user&gt; <span class="paren1">(<span class="code"><i><span class="symbol">loop</span></i> <span class="keyword">:for</span> i <span class="keyword">:upfrom</span> 2 <span class="keyword">:to</span> 10
               <span class="keyword">:for</span> j = <span class="paren2">(<span class="code">* 2 i</span>)</span>
               <span class="keyword">:when</span> <span class="paren2">(<span class="code">&lt; 10 j</span>)</span>
               <span class="keyword">:sum</span> j</span>)</span>
80
cl-user&gt; <span class="paren1">(<span class="code">series:collect-sum<span class="paren2">(<span class="code">series:choose-if #`<span class="paren3">(<span class="code">% '&gt; _ 10</span>)</span>
                                              <span class="paren3">(<span class="code">series:map-fn 'fixnum #`<span class="paren4">(<span class="code">% '* 2</span>)</span>
                                                             <span class="paren4">(<span class="code">series:scan-range <span class="keyword">:from</span> 2 <span class="keyword">:upto</span> 10</span>)</span></span>)</span></span>)</span></span>)</span>
80</span></code></pre>

<p>直訳は中間リストが多く作られるので効率が悪い。
<code>LOOP</code>マクロなら中間リストは作られないので効率が良い。
シンタックスをHaskellを近づけたいならSERIESが良い。</p>

<pre><code><span class="code">cl-user&gt; <span class="paren1">(<span class="code">mapcar #`<span class="paren2">(<span class="code">% 'funcall _ 3</span>)</span> `<span class="paren2">(<span class="code">,#`<span class="paren3">(<span class="code">% '+ 4</span>)</span> ,#`<span class="paren3">(<span class="code">% '* 10</span>)</span> ,#`<span class="paren3">(<span class="code">% 'expt _ 2</span>)</span> sqrt</span>)</span></span>)</span>
<span class="paren1">(<span class="code">7 30 9 1.7320508</span>)</span></span></code></pre>

<h2>5.7</h2>

<pre><code><span class="code"><span class="function">ghci</span><span class="atom">&gt;</span> map <span class="paren1">(<span class="code"><span class="keyword">\</span>x <span class="keyword">-&gt;</span> negate <span class="paren2">(<span class="code">abs x</span>)</span></span>)</span><span class="paren1">[<span class="code">5,<span class="atom">-</span>3,<span class="atom">-</span>6,7,<span class="atom">-</span>3,2,<span class="atom">-</span>19,24</span>]</span>
<span class="paren1">[<span class="code"><span class="atom">-</span>5,<span class="atom">-</span>3,<span class="atom">-</span>6,<span class="atom">-</span>7,<span class="atom">-</span>3,<span class="atom">-</span>2,<span class="atom">-</span>19,<span class="atom">-</span>24</span>]</span>
<span class="function">ghci</span><span class="atom">&gt;</span> map <span class="paren1">(<span class="code">negate <span class="atom">.</span> abs</span>)</span> <span class="paren1">[<span class="code">5,<span class="atom">-</span>3,<span class="atom">-</span>6,7,<span class="atom">-</span>3,2,<span class="atom">-</span>19,24</span>]</span>
<span class="paren1">[<span class="code"><span class="atom">-</span>5,<span class="atom">-</span>3,<span class="atom">-</span>6,<span class="atom">-</span>7,<span class="atom">-</span>3,<span class="atom">-</span>2,<span class="atom">-</span>19,<span class="atom">-</span>24</span>]</span>
<span class="function">ghci</span><span class="atom">&gt;</span> map <span class="paren1">(<span class="code"><span class="keyword">\</span>xs <span class="keyword">-&gt;</span> negate <span class="paren2">(<span class="code">sum <span class="paren3">(<span class="code">tail xs</span>)</span></span>)</span></span>)</span><span class="paren1">[<span class="code"><span class="paren2">[<span class="code">1<span class="keyword">..</span>5</span>]</span>,<span class="paren2">[<span class="code">3<span class="keyword">..</span>6</span>]</span>,<span class="paren2">[<span class="code">1<span class="keyword">..</span>7</span>]</span></span>]</span>
<span class="paren1">[<span class="code"><span class="atom">-</span>14,<span class="atom">-</span>15,<span class="atom">-</span>27</span>]</span>
<span class="function">ghci</span><span class="atom">&gt;</span> map <span class="paren1">(<span class="code">negate <span class="atom">.</span> sum <span class="atom">.</span> tail</span>)</span><span class="paren1">[<span class="code"><span class="paren2">[<span class="code">1<span class="keyword">..</span>5</span>]</span>,<span class="paren2">[<span class="code">3<span class="keyword">..</span>6</span>]</span>,<span class="paren2">[<span class="code">1<span class="keyword">..</span>7</span>]</span></span>]</span>
<span class="paren1">[<span class="code"><span class="atom">-</span>14,<span class="atom">-</span>15,<span class="atom">-</span>27</span>]</span></span></code></pre>

<p>関数合成はalexandriaの<code>COMPOSE</code>で行える。
本章冒頭で導入したリーダマクロでは<code>+</code>オペレータが関数合成を担う。</p>

<pre><code><span class="code">cl-user&gt; <span class="paren1">(<span class="code">mapcar #`<span class="paren2">(<span class="code">+ '- 'abs</span>)</span>'<span class="paren2">(<span class="code">5 -3 -6 7 -3 2 -19 24</span>)</span></span>)</span>
<span class="paren1">(<span class="code">-5 -3 -6 -7 -3 -2 -19 -24</span>)</span>
cl-user&gt; <span class="paren1">(<span class="code">mapcar #`<span class="paren2">(<span class="code">+ '- #`<span class="paren3">(<span class="code">% 'apply '+</span>)</span> 'cdr</span>)</span>
                 <span class="paren2">(<span class="code">list <span class="paren3">(<span class="code">incf-cl:range 1 5</span>)</span><span class="paren3">(<span class="code">incf-cl:range 3 6</span>)</span><span class="paren3">(<span class="code">incf-cl:range 1 7</span>)</span></span>)</span></span>)</span>
<span class="paren1">(<span class="code">-14 -15 -27</span>)</span></span></code></pre>

<h3>compose</h3>

<pre><code><span class="code"><span class="function">ghci</span><span class="atom">&gt;</span> sum <span class="paren1">(<span class="code">replicate 5 <span class="paren2">(<span class="code">max 6<span class="atom">.</span>7 8<span class="atom">.</span>9</span>)</span></span>)</span>
<span class="atom">====&gt;</span> <span class="paren1">(<span class="code">sum <span class="atom">.</span> replicate 5</span>)</span> <span class="paren1">(<span class="code">max 6<span class="atom">.</span>7 8<span class="atom">.</span>9</span>)</span>
<span class="atom">====&gt;</span> sum <span class="atom">.</span> replicate 5 <span class="atom">$</span> max 6<span class="atom">.</span>7 8<span class="atom">.</span>9

<span class="function">ghci</span><span class="atom">&gt;</span> replicate 2 <span class="atom">.</span> product <span class="atom">.</span> map <span class="paren1">(<span class="code"><span class="atom">*</span>3</span>)</span> <span class="atom">$</span> zipWith max <span class="paren1">[<span class="code">1,2</span>]</span> <span class="paren1">[<span class="code">4,5</span>]</span></span></code></pre>

<pre><code><span class="code">cl-user&gt; <span class="paren1">(<span class="code">funcall #`<span class="paren2">(<span class="code">+ #`<span class="paren3">(<span class="code">% 'make-list 2 <span class="keyword">:initial-element</span> _</span>)</span> #`<span class="paren3">(<span class="code">% 'apply '*</span>)</span> #`<span class="paren3">(<span class="code">% 'mapcar #`<span class="paren4">(<span class="code">% '* _ 3</span>)</span></span>)</span></span>)</span>
                  <span class="paren2">(<span class="code">mapcar #'max '<span class="paren3">(<span class="code">1 2</span>)</span>'<span class="paren3">(<span class="code">4 5</span>)</span></span>)</span></span>)</span>
<span class="comment">;; or
</span>cl-user&gt; <span class="paren1">(<span class="code">make-list 2 <span class="keyword">:initial-element</span> <span class="paren2">(<span class="code">apply #'* <span class="paren3">(<span class="code">mapcar #`<span class="paren4">(<span class="code">% '* 3</span>)</span><span class="paren4">(<span class="code">mapcar 'max '<span class="paren5">(<span class="code">1 2</span>)</span>'<span class="paren5">(<span class="code">4 5</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>
<span class="comment">;; or
</span>cl-user&gt; <span class="paren1">(<span class="code">make-list 2 <span class="keyword">:initial-element</span> <span class="paren2">(<span class="code"><i><span class="symbol">loop</span></i> <span class="keyword">:for</span> a <span class="keyword">:in</span> '<span class="paren3">(<span class="code">1 2</span>)</span>
                                             <span class="keyword">:for</span> b <span class="keyword">:in</span> '<span class="paren3">(<span class="code">4 5</span>)</span>
                                             <span class="keyword">:for</span> c = <span class="paren3">(<span class="code">* 3 <span class="paren4">(<span class="code">max a b</span>)</span></span>)</span> <span class="keyword">:then</span> <span class="paren3">(<span class="code">* c 3 <span class="paren4">(<span class="code">max a b</span>)</span></span>)</span>
                                             <span class="keyword">:finally</span> <span class="paren3">(<span class="code">return c</span>)</span></span>)</span></span>)</span>
<span class="comment">;; or
</span>cl-user&gt; <span class="paren1">(<span class="code">make-list 2 <span class="keyword">:initial-element</span> <span class="paren2">(<span class="code">series:collect-product <span class="paren3">(<span class="code">series:map-fn 'fixnum #`<span class="paren4">(<span class="code">% '* 3</span>)</span>
                                                                              <span class="paren4">(<span class="code">series:map-fn 'fixnum #'max <span class="paren5">(<span class="code">series:scan '<span class="paren6">(<span class="code">1 2</span>)</span></span>)</span><span class="paren5">(<span class="code">series:scan '<span class="paren6">(<span class="code">4 5</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<p>Common Lispで無理に関数合成を駆使しようとすると、かえって読みづらくなる気がする。
Haskellの美しさが際立つ例かと思う。
この例ではSERIESが美しさと効率の両立で健闘しているように見える。</p>

<h3>point free style</h3>

<pre><code><span class="code"><span class="function">sum'</span> <span class="keyword">::</span> <span class="paren1">(<span class="code"><span class="variable">Num</span> a</span>)</span> <span class="atom">=&gt;</span> <span class="paren1">[<span class="code">a</span>]</span> <span class="keyword">-&gt;</span> a
<span class="function">sum'</span> xs <span class="keyword">=</span> foldl <span class="paren1">(<span class="code"><span class="atom">+</span></span>)</span> 0 xs
;; or
<span class="function">sum'</span> <span class="keyword">=</span> foldl <span class="paren1">(<span class="code"><span class="atom">+</span></span>)</span> 0

<span class="function">fn</span> x <span class="keyword">=</span> ceiling <span class="paren1">(<span class="code">negate <span class="paren2">(<span class="code">tan <span class="paren3">(<span class="code">cos <span class="paren4">(<span class="code">max 50 x</span>)</span></span>)</span></span>)</span></span>)</span>
;; or
<span class="function">fn</span> <span class="keyword">=</span> ceiling <span class="atom">.</span> negate <span class="atom">.</span> tan <span class="atom">.</span> cos <span class="atom">.</span> max 50</span></code></pre>

<pre><code><span class="code"><span class="paren1">(<span class="code">declaim<span class="paren2">(<span class="code">ftype<span class="paren3">(<span class="code"><i><span class="symbol">function</span></i><span class="paren4">(<span class="code">list</span>)</span>fixnum</span>)</span>sum</span>)</span></span>)</span>
<span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> sum<span class="paren2">(<span class="code">list</span>)</span>
  <span class="paren2">(<span class="code">apply #'+ list</span>)</span></span>)</span>
<span class="comment">;; or
</span><span class="paren1">(<span class="code">setf <span class="paren2">(<span class="code">symbol-function 'sum</span>)</span> #`<span class="paren2">(<span class="code">% 'apply '+</span>)</span></span>)</span>

<span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> fn <span class="paren2">(<span class="code">x</span>)</span>
  <span class="paren2">(<span class="code">ceiling<span class="paren3">(<span class="code">- <span class="paren4">(<span class="code">tan <span class="paren5">(<span class="code">cos <span class="paren6">(<span class="code">max 50 x</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>
<span class="comment">;; or
</span><span class="paren1">(<span class="code">setf <span class="paren2">(<span class="code">symbol-function 'fn</span>)</span> #`<span class="paren2">(<span class="code">+ 'ceiling '- 'tan 'cos #`<span class="paren3">(<span class="code">% 'max 50</span>)</span></span>)</span></span>)</span></span></code></pre>

<p>関数を返すコマンドの返り値を<code>SYMBOL-FUNCTION</code>に代入すれば、暗黙裏の仮引数に依存出来て明示的にラムダリストを書かなくても済むようになるが、「ポイントフリースタイル」だとかいう仰々しい名前をつけて騒ぐほどのことではないと思う。
ただし、それはCommon Lispに於いては、の話であって、Haskellに於いてはほぼ同じシンタックスで仮引数を無くせるというのは、なかなか面白い現象で、そのような特徴的な現象には名前がついていてしかるべきだろうとも思う。</p>

<footer>
  <a href='../archives.html'>Archives
  </a>
</footer>
</body>
</html>