<!DOCTYPE HTML>
<HTML>
  <HEAD>
    <TITLE>cl-vs-haskell.7</TITLE>
    <META CHARSET='UTF-8'>
    <META NAME='auhtor' CONTENT='hyotang666'>
    <META NAME='generator' CONTENT='pages'>
    <LINK REL='stylesheet' HREF='../css/css.css' TYPE='text/css'>
  </HEAD>
  <BODY>
    <MAIN>
      <h1>Common Lisp vs Haskell, Chapter 7</h1>

<h2>Meta note</h2>

<h3>対象読者</h3>

<p><a href="cl-vs-haskell.6.html" >前章</a>を読了済みの者。</p>

<h2>Introduction</h2>

<p>本稿は「すごいH本」の内容をCommon Lispに翻訳しながらCLerがHaskellを学ぶその第7章である。
本章ではHaskellの<code>data</code>、<code>class</code>、<code>instance</code>キーワードを、すなわち、代数的データ型（Algebraic Data Type）、型クラスをCommon Lispで実装しながら学ぶ。</p>

<p>初級CLerは着いてこれなくなるかと思う。
こまかいコードは読まず、本文のみをざっと流し読みし雰囲気だけ汲み取り「Common Lispではこういうことができるのだなぁ」と思っていただければ幸い。
気合が入っている方は実力を付けてから、また読み返していただければ良い。</p>

<p>逆に中級CLerはコードをちゃんと読まないと着いてこれなくなるかと思われる。
難しさの度合いとしては、実践Common Lispのバイナリパーサの章と同等以上と捉えていただければ目安として分かりやすかろうと思う。
幸い、原著の各節に沿って、機能が紹介される毎にコードを拡張していくというスタイルを取っているので、一歩づつ読み解いていけば着いてこれないことはないと思う。</p>

<p>上級CLerの方は、ADTの実装や型クラスの実装に興味があるなら大変楽しく読めるかと思う。
そうでないなら「君はそう書くフレンズなんだね」以上の感想にはならないかと思われる。
「型クラスの実装」だとティンと来ないかもしれないが、「型情報を頼りにメソッドディスパッチをコンパイル時に解決することでオーバーヘッド無しにポリモーフィズムの恩恵を得られるようにする」と言えば興味を持つ方もおられるのではあるまいか。</p>

<p>なお、ここで書かれるコードは原著の例題が動けばそれだけで良いとするものなので、汎用的なものとしては欠陥だらけであることを始めに白状しておく。
実際本稿での実装では11章で出てくるApplicative Functorの実装が出来ない。</p>

<p>Haskellerをはじめとする非Lisperで読んでいる方がいれば、本章はCommon Lispが持つマクロの強力さと、その強力さを得るために付き合っていかなければならない醜さとを痛感できる章になっているかと思う。</p>

<p>本章は原著でも最も長い章だけあって、恐ろしく長く濃い。
たっぷりのコーヒーとチョコレート、そして数日に分けなければ読み切れないかもしれないというちょっぴりの覚悟を持ってお読み頂ければ幸い。</p>

<h1>7</h1>

<h2>7.1</h2>

<pre><code><span class="code"><span class="keyword">data</span> <span class="variable">Bool</span> <span class="keyword">=</span> <span class="variable">False</span> <span class="keyword">|</span> <span class="variable">True</span></span></code></pre>

<p>単にそれっぽくするだけなら、上記HaskellコードはCommon Lispに於いては<code>DEFTYPE</code>を使用することで再現できる。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">deftype</span></i> bool<span class="paren2">(<span class="code"></span>)</span>
  '<span class="paren2">(<span class="code">member false true</span>)</span></span>)</span></span></code></pre>

<p>これでシンボル<code>FALSE</code>とシンボル<code>TRUE</code>は<code>BOOL</code>という型であるという事を表している。</p>

<h2>7.2</h2>

<pre><code><span class="code"><span class="keyword">data</span> <span class="variable">Shape</span> <span class="keyword">=</span> <span class="variable">Circle</span> <span class="variable">Float</span> <span class="variable">Float</span> <span class="variable">Float</span> <span class="keyword">|</span>
&nbsp;            <span class="variable">Rectangle</span> <span class="variable">Float</span> <span class="variable">Float</span> <span class="variable">Float</span> <span class="variable">Float</span></span></code></pre>

<p>Haskellのdataキーワードに相当するものはCommon Lispには存在しない。
上記Haskellコードと等価なCommon Lispコードは以下のようなものとなる。</p>

<pre><code><span class="code"><span class="comment">;; helper
</span><span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> cons-type-specifier<span class="paren2">(<span class="code">types</span>)</span>
  <span class="paren2">(<span class="code"><i><span class="symbol">if</span></i><span class="paren3">(<span class="code">endp types</span>)</span>
    'null
    `<span class="paren3">(<span class="code">cons ,<span class="paren4">(<span class="code">car types</span>)</span>,<span class="paren4">(<span class="code">cons-type-specifier <span class="paren5">(<span class="code">cdr types</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>

<span class="comment">;; type
</span><span class="paren1">(<span class="code"><i><span class="symbol">deftype</span></i> shape<span class="paren2">(<span class="code"></span>)</span>
 `<span class="paren2">(<span class="code">or ,<span class="paren3">(<span class="code">cons-type-specifier '<span class="paren4">(<span class="code"><span class="paren5">(<span class="code">eql circle</span>)</span>real real real</span>)</span></span>)</span>
      ,<span class="paren3">(<span class="code">cons-type-specifier '<span class="paren4">(<span class="code"><span class="paren5">(<span class="code">eql rectangle</span>)</span> real real real real</span>)</span></span>)</span></span>)</span></span>)</span>

<span class="comment">;; constructors
</span><span class="paren1">(<span class="code">declaim<span class="paren2">(<span class="code">ftype<span class="paren3">(<span class="code"><i><span class="symbol">function</span></i><span class="paren4">(<span class="code">real real real</span>)</span>shape</span>)</span>circle</span>)</span></span>)</span>
<span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> circle<span class="paren2">(<span class="code">a b c</span>)</span>
  <span class="paren2">(<span class="code">list 'circle a b c</span>)</span></span>)</span>

<span class="paren1">(<span class="code">declaim<span class="paren2">(<span class="code">ftype<span class="paren3">(<span class="code"><i><span class="symbol">function</span></i><span class="paren4">(<span class="code">real real real real</span>)</span>shape</span>)</span>rectngle</span>)</span></span>)</span>
<span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> rectangle<span class="paren2">(<span class="code">a b c d</span>)</span>
  <span class="paren2">(<span class="code">list 'rectangle a b c d</span>)</span></span>)</span></span></code></pre>

<p>マクロにしてしまおう。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">defmacro</span></i> <i><span class="symbol">defdata</span></i><span class="paren2">(<span class="code">name &amp;rest constructor*</span>)</span>
  `<span class="paren2">(<span class="code"><i><span class="symbol">EVAL-WHEN</span></i><span class="paren3">(<span class="code"><span class="keyword">:COMPILE-TOPLEVEL</span> <span class="keyword">:LOAD-TOPLEVEL</span> <span class="keyword">:EXECUTE</span></span>)</span>
     <span class="paren3">(<span class="code"><i><span class="symbol">DEFTYPE</span></i> ,name<span class="paren4">(<span class="code"></span>)</span>
       '<span class="paren4">(<span class="code">OR ,@<span class="paren5">(<span class="code">mapcar <span class="paren6">(<span class="code"><i><span class="symbol">lambda</span></i><span class="paren1">(<span class="code">constructor</span>)</span>
                        <span class="paren1">(<span class="code">cons-type-specifier
                         `<span class="paren2">(<span class="code"><span class="paren3">(<span class="code">EQL ,<span class="paren4">(<span class="code">car constructor</span>)</span></span>)</span> ,@<span class="paren3">(<span class="code">cdr constructor</span>)</span></span>)</span></span>)</span></span>)</span>
                      constructor*</span>)</span></span>)</span></span>)</span>
     ,@<span class="paren3">(<span class="code">mapcan <span class="paren4">(<span class="code"><i><span class="symbol">lambda</span></i><span class="paren5">(<span class="code">constructor</span>)</span>
                 <span class="paren5">(<span class="code"><i><span class="symbol">let</span></i><span class="paren6">(<span class="code"><span class="paren1">(<span class="code">lambda-list<span class="paren2">(<span class="code"><i><span class="symbol">loop</span></i> <span class="keyword">:repeat</span> <span class="paren3">(<span class="code">length<span class="paren4">(<span class="code">cdr constructor</span>)</span></span>)</span>
                                        <span class="keyword">:collect</span> <span class="paren3">(<span class="code">gensym</span>)</span></span>)</span></span>)</span></span>)</span>
                   `<span class="paren6">(<span class="code"><span class="paren1">(<span class="code">DECLAIM<span class="paren2">(<span class="code">FTYPE<span class="paren3">(<span class="code"><i><span class="symbol">FUNCTION</span></i>,<span class="paren4">(<span class="code">cdr constructor</span>)</span>,name</span>)</span>,<span class="paren3">(<span class="code">car constructor</span>)</span></span>)</span></span>)</span>
                     <span class="paren1">(<span class="code"><i><span class="symbol">DEFUN</span></i> ,<span class="paren2">(<span class="code">car constructor</span>)</span>,lambda-list
                       <span class="paren2">(<span class="code">LIST ',<span class="paren3">(<span class="code">car constructor</span>)</span>,@lambda-list</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>
               constructor*</span>)</span>
     ',name</span>)</span></span>)</span></span></code></pre>

<p>これで以下のように書ける。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">defdata</span></i> shape
  <span class="paren2">(<span class="code">circle real real real</span>)</span>
  <span class="paren2">(<span class="code">rectangle real real real real</span>)</span></span>)</span></span></code></pre>

<pre><code><span class="code"><span class="function">ghci</span><span class="atom">&gt;</span> <span class="variable">:</span>t <span class="variable">Circle</span>
<span class="variable">Circle</span> <span class="keyword">::</span> <span class="variable">Float</span> <span class="keyword">-&gt;</span> <span class="variable">Float</span> <span class="keyword">-&gt;</span> <span class="variable">Float</span> <span class="keyword">-&gt;</span> <span class="variable">Shape</span></span></code></pre>

<pre><code><span class="code">cl-user&gt; <span class="paren1">(<span class="code">inspect #'circle</span>)</span>
<span class="comment">;; The object is a FUNCTION named CIRCLE.
</span><span class="comment">;; 0. Lambda-list: (#:G611 #:G612 #:G613)
</span><span class="comment">;; 1. Ftype: (FUNCTION (REAL REAL REAL)
</span><span class="comment">;;            (VALUES
</span><span class="comment">;;             (OR
</span><span class="comment">;;              (CONS (MEMBER CIRCLE)
</span><span class="comment">;;                    (CONS REAL (CONS REAL (CONS REAL NULL))))
</span><span class="comment">;;              (CONS (MEMBER RECTANGLE)
</span><span class="comment">;;                    (CONS REAL
</span><span class="comment">;;                          (CONS REAL
</span><span class="comment">;;                                (CONS REAL (CONS REAL NULL))))))
</span><span class="comment">;;             &amp;OPTIONAL))</span></span></code></pre>

<pre><code><span class="code"><span class="function">area</span> <span class="keyword">::</span> <span class="variable">Shape</span> <span class="keyword">-&gt;</span> <span class="variable">Float</span>
<span class="function">area</span> <span class="paren1">(<span class="code"><span class="variable">Circle</span> _ _ r</span>)</span> <span class="keyword">=</span> pi <span class="atom">*</span> r <span class="atom">^</span> 2
<span class="function">area</span> <span class="paren1">(<span class="code"><span class="variable">Rectangle</span> x1 y1 x2 y2</span>)</span> <span class="keyword">=</span> <span class="paren1">(<span class="code">abs <span class="atom">$</span> x2 <span class="atom">-</span> x1</span>)</span> <span class="atom">*</span> <span class="paren1">(<span class="code">abs <span class="atom">$</span> y2 <span class="atom">-</span> y1</span>)</span></span></code></pre>

<pre><code><span class="code"><span class="paren1">(<span class="code">declaim<span class="paren2">(<span class="code">ftype<span class="paren3">(<span class="code"><i><span class="symbol">function</span></i><span class="paren4">(<span class="code">shape</span>)</span>real</span>)</span>area</span>)</span></span>)</span>
<span class="paren1">(<span class="code"><i><span class="symbol">trivia:defun-ematch</span></i> area<span class="paren2">(<span class="code">shape</span>)</span>
  <span class="paren2">(<span class="code"><span class="paren3">(<span class="code">list <span class="paren4">(<span class="code">eq 'circle</span>)</span> _ _ r</span>)</span>
   <span class="paren3">(<span class="code">infix-math:$ pi * r infix-math:^ 2</span>)</span></span>)</span>
  <span class="paren2">(<span class="code"><span class="paren3">(<span class="code">list <span class="paren4">(<span class="code">eq 'rectangle</span>)</span> x1 y1 x2 y2</span>)</span>
   <span class="paren3">(<span class="code">infix-math:$ <span class="paren4">(<span class="code">abs x2 - x1</span>)</span> * <span class="paren4">(<span class="code">abs y2 - y1</span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<p><code>DECLAIM</code>で返り値を<code>REAL</code>と宣言してあるので、<code>DEFUN-EMATCH</code>でないとコンパイラがクレームをつけてくる点要注意。
<code>DEFUN-MATCH</code>は<code>NIL</code>が返る可能性があり、<code>NIL</code>は<code>REAL</code>でないからだ。</p>

<p>ところで、パターンマッチの構文がなんとも煩わしいので、triviaの<code>DEFPATTERN</code>でパターンを定義してしまおう。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> &lt;pattern-matcher&gt;<span class="paren2">(<span class="code">constructor</span>)</span>
  <span class="paren2">(<span class="code">when<span class="paren3">(<span class="code">listp constructor</span>)</span>
    <span class="paren3">(<span class="code"><i><span class="symbol">let</span></i><span class="paren4">(<span class="code"><span class="paren5">(<span class="code">name<span class="paren6">(<span class="code">car constructor</span>)</span></span>)</span></span>)</span>
      `<span class="paren4">(<span class="code"><span class="paren5">(<span class="code"><i><span class="symbol">TRIVIA:DEFPATTERN</span></i>,name<span class="paren6">(<span class="code">&amp;REST ARGS</span>)</span>
          `<span class="paren6">(<span class="code">LIST <span class="paren1">(<span class="code">EQ ',',name</span>)</span> ,@ARGS</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>

<span class="paren1">(<span class="code"><i><span class="symbol">defmacro</span></i> <i><span class="symbol">defdata</span></i><span class="paren2">(<span class="code">name &amp;rest constructor*</span>)</span>
  `<span class="paren2">(<span class="code"><i><span class="symbol">EVAL-WHEN</span></i><span class="paren3">(<span class="code"><span class="keyword">:COMPILE-TOPLEVEL</span> <span class="keyword">:LOAD-TOPLEVEL</span> <span class="keyword">:EXECUTE</span></span>)</span>
     <span class="paren3">(<span class="code"><i><span class="symbol">DEFTYPE</span></i> ,name<span class="paren4">(<span class="code"></span>)</span>
       '<span class="paren4">(<span class="code">OR ,@<span class="paren5">(<span class="code">mapcar <span class="paren6">(<span class="code"><i><span class="symbol">lambda</span></i><span class="paren1">(<span class="code">constructor</span>)</span>
                        <span class="paren1">(<span class="code">cons-type-specifier
                         `<span class="paren2">(<span class="code"><span class="paren3">(<span class="code">EQL ,<span class="paren4">(<span class="code">car constructor</span>)</span></span>)</span> ,@<span class="paren3">(<span class="code">cdr constructor</span>)</span></span>)</span></span>)</span></span>)</span>
                      constructor*</span>)</span></span>)</span></span>)</span>
     ,@<span class="paren3">(<span class="code">mapcan <span class="paren4">(<span class="code"><i><span class="symbol">lambda</span></i><span class="paren5">(<span class="code">constructor</span>)</span>
                 <span class="paren5">(<span class="code"><i><span class="symbol">let</span></i><span class="paren6">(<span class="code"><span class="paren1">(<span class="code">lambda-list<span class="paren2">(<span class="code"><i><span class="symbol">loop</span></i> <span class="keyword">:repeat</span> <span class="paren3">(<span class="code">length<span class="paren4">(<span class="code">cdr constructor</span>)</span></span>)</span>
                                        <span class="keyword">:collect</span> <span class="paren3">(<span class="code">gensym</span>)</span></span>)</span></span>)</span></span>)</span>
                   `<span class="paren6">(<span class="code"><span class="paren1">(<span class="code">DECLAIM<span class="paren2">(<span class="code">FTYPE<span class="paren3">(<span class="code"><i><span class="symbol">FUNCTION</span></i>,<span class="paren4">(<span class="code">cdr constructor</span>)</span>,name</span>)</span>,<span class="paren3">(<span class="code">car constructor</span>)</span></span>)</span></span>)</span>
                     <span class="paren1">(<span class="code"><i><span class="symbol">DEFUN</span></i> ,<span class="paren2">(<span class="code">car constructor</span>)</span>,lambda-list
                       <span class="paren2">(<span class="code">LIST ',<span class="paren3">(<span class="code">car constructor</span>)</span>,@lambda-list</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>
               constructor*</span>)</span>
     ,@<span class="paren3">(<span class="code">mapcan #'&lt;pattern-matcher&gt; constructor*</span>)</span>
     ',name</span>)</span></span>)</span></span></code></pre>

<p>これで以下のように書ける。
なお、<code>SHAPE</code>型の再定義を忘れぬよう。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">declaim<span class="paren2">(<span class="code">ftype<span class="paren3">(<span class="code"><i><span class="symbol">function</span></i><span class="paren4">(<span class="code">shape</span>)</span>real</span>)</span>area</span>)</span></span>)</span>
<span class="paren1">(<span class="code"><i><span class="symbol">trivia:defun-ematch</span></i> area <span class="paren2">(<span class="code">shape</span>)</span>
 <span class="paren2">(<span class="code"><span class="paren3">(<span class="code">circle _ _ r</span>)</span><span class="paren3">(<span class="code">infix-math:$ pi * r infix-math:^ 2</span>)</span></span>)</span>
 <span class="paren2">(<span class="code"><span class="paren3">(<span class="code">rectangle x1 y1 x2 y2</span>)</span><span class="paren3">(<span class="code">infix-math:$ <span class="paren4">(<span class="code">abs x2 - x1</span>)</span> * <span class="paren4">(<span class="code">abs y2 - y1</span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<pre><code><span class="code"><span class="function">ghci</span><span class="atom">&gt;</span> map <span class="paren1">(<span class="code"><span class="variable">Circle</span> 10 20</span>)</span> <span class="paren1">[<span class="code">4,5,6,6</span>]</span>
<span class="paren1">[<span class="code"><span class="variable">Circle</span> 10<span class="atom">.</span>0 20<span class="atom">.</span>0 4<span class="atom">.</span>0, <span class="variable">Circle</span> 10<span class="atom">.</span>0 20<span class="atom">.</span>0 5<span class="atom">.</span>0, <span class="variable">Circle</span> 10<span class="atom">.</span>0 20<span class="atom">.</span>0 6<span class="atom">.</span>0, <span class="variable">Circle</span> 10<span class="atom">.</span>0 20<span class="atom">.</span>0 6<span class="atom">.</span>0</span>]</span></span></code></pre>

<pre><code><span class="code">cl-user&gt; <span class="paren1">(<span class="code">mapcar #`<span class="paren2">(<span class="code">% 'circle 10 20</span>)</span>'<span class="paren2">(<span class="code">4 5 6 6</span>)</span></span>)</span>
<span class="paren1">(<span class="code"><span class="paren2">(<span class="code">circle 10 20 4</span>)</span><span class="paren2">(<span class="code">circle 10 20 5</span>)</span><span class="paren2">(<span class="code">circle 10 20 6</span>)</span><span class="paren2">(<span class="code">circle 10 20 6</span>)</span></span>)</span></span></code></pre>

<p>Common Lispに於いて<code>FLOAT</code>と<code>INTEGER</code>は明確に区別されるので、ここではそれらを統合した型<code>REAL</code>を使っている点要注意。</p>

<h3>Point data type</h3>

<pre><code><span class="code"><span class="keyword">data</span> <span class="variable">Point</span> <span class="keyword">=</span> <span class="variable">Point</span> <span class="variable">Float</span> <span class="variable">Float</span> <span class="keyword">deriving</span> <span class="paren1">(<span class="code"><span class="variable">Show</span></span>)</span>
<span class="keyword">data</span> <span class="variable">Shape</span> <span class="keyword">=</span> <span class="variable">Circle</span> <span class="variable">Point</span> <span class="variable">Float</span> <span class="keyword">|</span> <span class="variable">Rectangle</span> <span class="variable">Point</span> <span class="variable">Point</span> <span class="keyword">deriving</span> <span class="paren1">(<span class="code"><span class="variable">Show</span></span>)</span></span></code></pre>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">defdata</span></i> point <span class="paren2">(<span class="code">point real real</span>)</span></span>)</span>
<span class="paren1">(<span class="code"><i><span class="symbol">defdata</span></i> shape <span class="paren2">(<span class="code">circle point real</span>)</span><span class="paren2">(<span class="code">rectangle point point</span>)</span></span>)</span></span></code></pre>

<pre><code><span class="code"><span class="function">area</span> <span class="keyword">::</span> <span class="variable">Shape</span> <span class="keyword">-&gt;</span> <span class="variable">Float</span>
<span class="function">area</span> <span class="paren1">(<span class="code"><span class="variable">Circle</span> _ r</span>)</span> <span class="keyword">=</span> pi <span class="atom">*</span> r <span class="atom">^</span> 2
<span class="function">area</span> <span class="paren1">(<span class="code"><span class="variable">Rectangle</span> <span class="paren2">(<span class="code"><span class="variable">Point</span> x1 y1</span>)</span> <span class="paren2">(<span class="code"><span class="variable">Point</span> x2 y2</span>)</span></span>)</span> <span class="keyword">=</span> <span class="paren1">(<span class="code">abs <span class="atom">$</span> x2 <span class="atom">-</span> x1</span>)</span> <span class="atom">*</span> <span class="paren1">(<span class="code">abs <span class="atom">$</span> y2 <span class="atom">-</span> y1</span>)</span></span></code></pre>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">trivia:defun-ematch</span></i> area<span class="paren2">(<span class="code">shape</span>)</span>
  <span class="paren2">(<span class="code"><span class="paren3">(<span class="code">circle _ r</span>)</span> <span class="paren3">(<span class="code">infix-math:$ pi * r infix-math:^ 2</span>)</span></span>)</span>
  <span class="paren2">(<span class="code"><span class="paren3">(<span class="code">rectangle <span class="paren4">(<span class="code">point x1 y1</span>)</span> <span class="paren4">(<span class="code">point x2 y2</span>)</span></span>)</span>
   <span class="paren3">(<span class="code">infix-math:$ <span class="paren4">(<span class="code">abs x2 - x1</span>)</span> * <span class="paren4">(<span class="code">abs y2 - y1</span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<pre><code><span class="code"><span class="function">ghci</span><span class="atom">&gt;</span> area <span class="paren1">(<span class="code"><span class="variable">Rectangle</span> <span class="paren2">(<span class="code"><span class="variable">Point</span> 0 0</span>)</span><span class="paren2">(<span class="code"><span class="variable">Point</span> 100 100</span>)</span></span>)</span>
<span class="function">10000</span><span class="atom">.</span>0
<span class="function">ghci</span><span class="atom">&gt;</span> area <span class="paren1">(<span class="code"><span class="variable">Circle</span> <span class="paren2">(<span class="code"><span class="variable">Point</span> 0 0</span>)</span> 24</span>)</span>
<span class="function">1809</span><span class="atom">.</span>5574</span></code></pre>

<pre><code><span class="code">cl-user&gt; <span class="paren1">(<span class="code">area <span class="paren2">(<span class="code">rectangle <span class="paren3">(<span class="code">point 0 0</span>)</span><span class="paren3">(<span class="code">point 100 100</span>)</span></span>)</span></span>)</span>
10000
cl-user&gt; <span class="paren1">(<span class="code">area <span class="paren2">(<span class="code">circle <span class="paren3">(<span class="code">point 0 0</span>)</span> 24</span>)</span></span>)</span>
1809.5573684677208d0</span></code></pre>

<pre><code><span class="code"><span class="function">nudge</span> <span class="keyword">::</span> <span class="variable">Shape</span> <span class="keyword">-&gt;</span> <span class="variable">Float</span> <span class="keyword">-&gt;</span> <span class="variable">Float</span> <span class="keyword">-&gt;</span> <span class="variable">Shape</span>
<span class="function">nudge</span> <span class="paren1">(<span class="code"><span class="variable">Circle</span> <span class="paren2">(<span class="code"><span class="variable">Point</span> x y</span>)</span> r</span>)</span> a b <span class="keyword">=</span> <span class="variable">Circle</span> <span class="paren1">(<span class="code"><span class="variable">Point</span> <span class="paren2">(<span class="code">x<span class="atom">+</span>a</span>)</span><span class="paren2">(<span class="code">y<span class="atom">+</span>b</span>)</span>r</span>)</span>
<span class="function">nudge</span> <span class="paren1">(<span class="code"><span class="variable">Rectagle</span> <span class="paren2">(<span class="code"><span class="variable">Point</span> x1 y1</span>)</span> <span class="paren2">(<span class="code"><span class="variable">Point</span> x2 y2</span>)</span></span>)</span> a b
&nbsp;   <span class="keyword">=</span> <span class="variable">Rectangle</span> <span class="paren1">(<span class="code"><span class="variable">Point</span> <span class="paren2">(<span class="code">x1<span class="atom">+</span>a</span>)</span> <span class="paren2">(<span class="code">y1<span class="atom">+</span> b</span>)</span></span>)</span> <span class="paren1">(<span class="code"><span class="variable">Point</span> <span class="paren2">(<span class="code">x2<span class="atom">+</span>a</span>)</span> <span class="paren2">(<span class="code">y2<span class="atom">+</span>b</span>)</span></span>)</span></span></code></pre>

<pre><code><span class="code"><span class="paren1">(<span class="code">declaim<span class="paren2">(<span class="code">ftype<span class="paren3">(<span class="code"><i><span class="symbol">function</span></i><span class="paren4">(<span class="code">shape real real</span>)</span>shape</span>)</span>nudge</span>)</span></span>)</span>
<span class="paren1">(<span class="code"><i><span class="symbol">trivia:defun-ematch*</span></i> nudge<span class="paren2">(<span class="code">shape a b</span>)</span>
  <span class="paren2">(<span class="code"><span class="paren3">(<span class="code"><span class="paren4">(<span class="code">circle <span class="paren5">(<span class="code">point x y</span>)</span> r</span>)</span> a b</span>)</span>
   <span class="paren3">(<span class="code">circle <span class="paren4">(<span class="code">point <span class="paren5">(<span class="code">+ x a</span>)</span><span class="paren5">(<span class="code">+ y b</span>)</span></span>)</span> r</span>)</span></span>)</span>
  <span class="paren2">(<span class="code"><span class="paren3">(<span class="code"><span class="paren4">(<span class="code">rectangle <span class="paren5">(<span class="code">point x1 y1</span>)</span><span class="paren5">(<span class="code">point x2 y2</span>)</span></span>)</span> a b</span>)</span>
   <span class="paren3">(<span class="code">rectangle <span class="paren4">(<span class="code">point <span class="paren5">(<span class="code">+ x1 a</span>)</span><span class="paren5">(<span class="code">+ y1 b</span>)</span></span>)</span><span class="paren4">(<span class="code">point <span class="paren5">(<span class="code">+ x2 a</span>)</span><span class="paren5">(<span class="code">+ y2 b</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<p>単に束縛しなおしているだけの本来は必要のないパターンマッチはオーバーヘッドになるだけなので、以下のようにするほうが望ましかろう。</p>

<pre><code>(defun nudge(shape a b)
  (trivia:ematch shape
    ((circle (point x y) r)
     (circle (point (+ x y)(+ y b)) r))
    ((rectangle (point x1 y1)(point x2 y2))
     (rectangle (point (+ x1 a)(+ y1 b))(point (+ x2 a)(+ y2 b))))))</code></pre>

<h3>Export Shape as module</h3>

<pre><code><span class="code"><span class="keyword">module</span> <span class="variable">Shapes</span>
<span class="paren1">(<span class="code"> <span class="variable">Point</span><span class="paren2">(<span class="code"><span class="keyword">..</span></span>)</span>
, <span class="variable">Shape</span><span class="paren2">(<span class="code"><span class="keyword">..</span></span>)</span>
, area
, nudge
</span>)</span> <span class="keyword">where</span></span></code></pre>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">defpackage</span></i> <span class="keyword">:shapes</span><span class="paren2">(<span class="code"><span class="keyword">:use</span> <span class="keyword">:cl</span></span>)</span>
  <span class="paren2">(<span class="code"><span class="keyword">:export</span> <span class="comment">; types
</span>           <span class="keyword">#:shape</span></span>)</span>
  <span class="paren2">(<span class="code"><span class="keyword">:export</span> <span class="comment">; data constructors
</span>           <span class="keyword">#:point</span> <span class="keyword">#:circle</span> <span class="keyword">#:rectangle</span></span>)</span>
  <span class="paren2">(<span class="code"><span class="keyword">:export</span> <span class="comment">; main api
</span>           <span class="keyword">#:area</span> <span class="keyword">#:nudge</span></span>)</span></span>)</span></span></code></pre>

<h2>7.3</h2>

<pre><code><span class="code"><span class="keyword">data</span> <span class="variable">Person</span> <span class="keyword">=</span> <span class="variable">Person</span> <span class="paren1">{<span class="code"> firstName <span class="keyword">::</span> <span class="variable">String</span>
&nbsp;                    , lastName <span class="keyword">::</span> <span class="variable">String</span>
&nbsp;                    , age <span class="keyword">::</span> <span class="variable">Int</span>
&nbsp;                    , height <span class="keyword">::</span> <span class="variable">Float</span>
&nbsp;                    , phoneNumber <span class="keyword">::</span> <span class="variable">String</span>
&nbsp;                    , flavor <span class="keyword">::</span> <span class="variable">String</span> </span>}</span> <span class="keyword">deriving</span> <span class="paren1">(<span class="code"><span class="variable">Show</span></span>)</span></span></code></pre>

<p>上記HaskellコードはCommon Lispに於ける<code>DEFSTRUCT</code>とおよそ等価である。
以下のようにすれば再現できる。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">deftype</span></i> person<span class="paren2">(<span class="code"></span>)</span>
  <span class="paren2">(<span class="code">cons-type-specifier '<span class="paren3">(<span class="code">eql person</span>)</span>'string 'string 'fixnum 'float 'string 'string</span>)</span></span>)</span>
<span class="paren1">(<span class="code"><i><span class="symbol">defstruct</span></i><span class="paren2">(<span class="code">person <span class="keyword">:named</span> <span class="paren3">(<span class="code"><span class="keyword">:type</span> list</span>)</span><span class="paren3">(<span class="code"><span class="keyword">:conc-name</span> nil</span>)</span><span class="paren3">(<span class="code"><span class="keyword">:constructor</span> person</span>)</span>
                  <span class="paren3">(<span class="code"><span class="keyword">:copier</span> nil</span>)</span><span class="paren3">(<span class="code"><span class="keyword">:predicate</span> nil</span>)</span></span>)</span>
  <span class="paren2">(<span class="code">first-name <span class="paren3">(<span class="code">error <span class="string">"required"</span></span>)</span> <span class="keyword">:type</span> string</span>)</span>
  <span class="paren2">(<span class="code">last-name <span class="paren3">(<span class="code">error <span class="string">"required"</span></span>)</span> <span class="keyword">:type</span> string</span>)</span>
  <span class="paren2">(<span class="code">age <span class="paren3">(<span class="code">error <span class="string">"required"</span></span>)</span> <span class="keyword">:type</span> fixnum</span>)</span>
  <span class="paren2">(<span class="code">height <span class="paren3">(<span class="code">error <span class="string">"required"</span></span>)</span> <span class="keyword">:type</span> float</span>)</span>
  <span class="paren2">(<span class="code">phone-number <span class="paren3">(<span class="code">error <span class="string">"required"</span></span>)</span> <span class="keyword">:type</span> string</span>)</span>
  <span class="paren2">(<span class="code">flavor <span class="paren3">(<span class="code">error <span class="string">"required"</span></span>)</span> <span class="keyword">:type</span> string</span>)</span></span>)</span></span></code></pre>

<p>これも<code>DEFDATA</code>マクロに統合してしまおう。
マクロの規模が大きくなってきたので、リファクタリングもしておく。</p>

<pre><code><span class="code"><span class="comment">;;;; DEFDATA
</span><span class="paren1">(<span class="code"><i><span class="symbol">defmacro</span></i> <i><span class="symbol">defdata</span></i><span class="paren2">(<span class="code">name &amp;rest constructor*</span>)</span>
  `<span class="paren2">(<span class="code"><i><span class="symbol">EVAL-WHEN</span></i><span class="paren3">(<span class="code"><span class="keyword">:COMPILE-TOPLEVEL</span> <span class="keyword">:LOAD-TOPLEVEL</span> <span class="keyword">:EXECUTE</span></span>)</span>
     ,<span class="paren3">(<span class="code">&lt;<i><span class="symbol">deftype&gt;</span></i> name constructor*</span>)</span>
     ,@<span class="paren3">(<span class="code">mapcan #`<span class="paren4">(<span class="code">% '&lt;constructors&gt; name</span>)</span>constructor*</span>)</span>
     ,@<span class="paren3">(<span class="code">mapcan #'&lt;pattern-matcher&gt; constructor*</span>)</span>
     ',name</span>)</span></span>)</span>

<span class="comment">;;; &lt;deftype&gt;
</span><span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> &lt;<i><span class="symbol">deftype&gt;</span></i><span class="paren2">(<span class="code">name constructor*</span>)</span>
  <span class="paren2">(<span class="code"><i><span class="symbol">labels</span></i><span class="paren3">(<span class="code"><span class="paren4">(<span class="code">type-name<span class="paren5">(<span class="code">constructor</span>)</span>
            <span class="paren5">(<span class="code"><i><span class="symbol">cond</span></i>
              <span class="paren6">(<span class="code"><span class="paren1">(<span class="code">list-constructor-p constructor</span>)</span>
               <span class="paren1">(<span class="code">cons-type-specifier `<span class="paren2">(<span class="code"><span class="paren3">(<span class="code">eql ,<span class="paren4">(<span class="code">car constructor</span>)</span></span>)</span> ,@<span class="paren3">(<span class="code">cdr constructor</span>)</span></span>)</span></span>)</span></span>)</span>
              <span class="paren6">(<span class="code">t <span class="paren1">(<span class="code">cons-type-specifier
                  `<span class="paren2">(<span class="code"><span class="paren3">(<span class="code">eql ,<span class="paren4">(<span class="code">car constructor</span>)</span></span>)</span>
                    ,@<span class="paren3">(<span class="code"><i><span class="symbol">loop</span></i> <span class="keyword">:for</span> clause <span class="keyword">:in</span> <span class="paren4">(<span class="code">cdr constructor</span>)</span>
                            <span class="keyword">:collect</span> <span class="paren4">(<span class="code">or <span class="paren5">(<span class="code">getf clause <span class="keyword">:type</span></span>)</span>
                                         T</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>
    `<span class="paren3">(<span class="code"><i><span class="symbol">DEFTYPE</span></i>,name<span class="paren4">(<span class="code"></span>)</span>
       '<span class="paren4">(<span class="code">OR ,@<span class="paren5">(<span class="code">mapcar #'type-name constructor*</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>

<span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> list-constructor-p<span class="paren2">(<span class="code">constructor</span>)</span>
  <span class="paren2">(<span class="code">every #'millet:type-specifier-p <span class="paren3">(<span class="code">cdr constructor</span>)</span></span>)</span></span>)</span>

<span class="comment">;;; &lt;constructors&gt;
</span><span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> &lt;constructors&gt;<span class="paren2">(<span class="code">name constructor</span>)</span>
  <span class="paren2">(<span class="code"><i><span class="symbol">cond</span></i>
    <span class="paren3">(<span class="code"><span class="paren4">(<span class="code">list-constructor-p constructor</span>)</span>
     <span class="paren4">(<span class="code"><i><span class="symbol">let</span></i><span class="paren5">(<span class="code"><span class="paren6">(<span class="code">lambda-list<span class="paren1">(<span class="code"><i><span class="symbol">loop</span></i> <span class="keyword">:repeat</span> <span class="paren2">(<span class="code">length<span class="paren3">(<span class="code">cdr constructor</span>)</span></span>)</span>
                            <span class="keyword">:collect</span> <span class="paren2">(<span class="code">gensym</span>)</span></span>)</span></span>)</span></span>)</span>
       `<span class="paren5">(<span class="code"><span class="paren6">(<span class="code">DECLAIM<span class="paren1">(<span class="code">FTYPE<span class="paren2">(<span class="code"><i><span class="symbol">FUNCTION</span></i>,<span class="paren3">(<span class="code">cdr constructor</span>)</span>,name</span>)</span>,<span class="paren2">(<span class="code">car constructor</span>)</span></span>)</span></span>)</span>
         <span class="paren6">(<span class="code"><i><span class="symbol">DEFUN</span></i> ,<span class="paren1">(<span class="code">car constructor</span>)</span>,lambda-list
           <span class="paren1">(<span class="code">LIST ',<span class="paren2">(<span class="code">car constructor</span>)</span>,@lambda-list</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>
    <span class="paren3">(<span class="code">t `<span class="paren4">(<span class="code"><span class="paren5">(<span class="code"><i><span class="symbol">DEFSTRUCT</span></i><span class="paren6">(<span class="code">,name <span class="keyword">:NAMED</span> <span class="paren1">(<span class="code"><span class="keyword">:TYPE</span> LIST</span>)</span>
                          <span class="paren1">(<span class="code"><span class="keyword">:CONC-NAME</span> NIL</span>)</span>
                          <span class="paren1">(<span class="code"><span class="keyword">:COPIER</span> NIL</span>)</span>
                          <span class="paren1">(<span class="code"><span class="keyword">:PREDICATE</span> NIL</span>)</span>
                          <span class="paren1">(<span class="code"><span class="keyword">:CONSTRUCTOR</span> ,<span class="paren2">(<span class="code">car constructor</span>)</span></span>)</span></span>)</span>
           ,@<span class="paren6">(<span class="code">cdr constructor</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<p>これで以下のようにも書ける。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">defdata</span></i> person 
  <span class="paren2">(<span class="code">person <span class="paren3">(<span class="code">first-name <span class="string">""</span> <span class="keyword">:type</span> string</span>)</span>
          <span class="paren3">(<span class="code">last-name <span class="string">""</span> <span class="keyword">:type</span> string</span>)</span>
          <span class="paren3">(<span class="code">age 0 <span class="keyword">:type</span> fixnum</span>)</span>
          <span class="paren3">(<span class="code">height .0 <span class="keyword">:type</span> Float</span>)</span>
          <span class="paren3">(<span class="code">phone-number <span class="string">""</span> <span class="keyword">:type</span> string</span>)</span>
          <span class="paren3">(<span class="code">flavor <span class="string">""</span> <span class="keyword">:type</span> string</span>)</span></span>)</span></span>)</span></span></code></pre>

<pre><code><span class="code"><span class="function">ghci</span><span class="atom">&gt;</span> <span class="variable">:</span>t flavor
<span class="function">flavor</span> <span class="keyword">::</span> <span class="variable">Person</span> <span class="keyword">-&gt;</span> <span class="variable">String</span>
<span class="function">ghci</span><span class="atom">&gt;</span> <span class="variable">:</span>t firstName
<span class="function">firstName</span> <span class="keyword">::</span> <span class="variable">Person</span> <span class="keyword">-&gt;</span> <span class="variable">String</span></span></code></pre>

<pre><code><span class="code">cl-user&gt; <span class="paren1">(<span class="code">type-of #'flavor</span>)</span>
FUNCTION
cl-user&gt; <span class="paren1">(<span class="code">describe #'flavor</span>)</span>
<span class="comment">;; Lambda-list: (STRUCTURE)
</span><span class="comment">;; Derived type: (FUNCTION (LIST) (VALUES STRING &amp;OPTIONAL))
</span>cl-user&gt; <span class="paren1">(<span class="code">inspect #'flavor</span>)</span>
<span class="comment">;; The object is a FUNCTION named FLAVOR.
</span><span class="comment">;; 0. Lambda-list: (STRUCTURE)
</span><span class="comment">;; 1. Ftype: (FUNCTION (LIST) (VALUES STRING &amp;OPTIONAL))
</span>&gt; :q</span></code></pre>

<pre><code><span class="code"><span class="keyword">data</span> <span class="variable">Car</span> <span class="keyword">=</span> <span class="variable">Car</span> <span class="variable">String</span> <span class="variable">String</span> <span class="variable">Int</span> <span class="keyword">deriving</span> <span class="paren1">(<span class="code"><span class="variable">Show</span></span>)</span>

<span class="function">ghci</span><span class="atom">&gt;</span> <span class="variable">Car</span> <span class="string">"Ford"</span> <span class="string">"Mustang"</span> 1967
<span class="variable">Car</span> <span class="string">"Ford"</span> <span class="string">"Mustang"</span> 1967

<span class="keyword">data</span> <span class="variable">Car</span> <span class="keyword">=</span> <span class="variable">Car</span> <span class="paren1">{<span class="code"> company <span class="keyword">::</span> <span class="variable">String</span>
&nbsp;              , model <span class="keyword">::</span> <span class="variable">String</span>
&nbsp;              , year <span class="keyword">::</span> <span class="variable">Int</span>
&nbsp;              </span>}</span> <span class="keyword">deriving</span> <span class="paren1">(<span class="code"><span class="variable">Show</span></span>)</span>

<span class="function">ghci</span><span class="atom">&gt;</span> <span class="variable">Car</span> <span class="paren1">{<span class="code">company<span class="keyword">=</span><span class="string">"Ford"</span>, model<span class="keyword">=</span><span class="string">"Mustang"</span>, year<span class="keyword">=</span>1967</span>}</span>
<span class="variable">Car</span> <span class="paren1">{<span class="code">company <span class="keyword">=</span> <span class="string">"Ford"</span>, model <span class="keyword">=</span> <span class="string">"Mustang"</span>, year <span class="keyword">=</span> 1967</span>}</span></span></code></pre>

<p>型コンストラクタの名前が衝突するので、ここでは先頭に<code>.</code>を付けて回避しておく。</p>

<pre><code><span class="code">cl-user&gt; <span class="paren1">(<span class="code"><i><span class="symbol">defdata</span></i> .car <span class="paren2">(<span class="code">.car string string fixnum</span>)</span></span>)</span>
cl-user&gt; <span class="paren1">(<span class="code">.car <span class="string">"Ford"</span> <span class="string">"Mustang"</span> 1967</span>)</span>
<span class="paren1">(<span class="code">.CAR <span class="string">"Ford"</span> <span class="string">"Mustang"</span> 1967</span>)</span>
cl-user&gt; <span class="paren1">(<span class="code"><i><span class="symbol">defdata</span></i> .car <span class="paren2">(<span class="code">.car <span class="paren3">(<span class="code">company <span class="string">""</span> <span class="keyword">:type</span> string</span>)</span>
                             <span class="paren3">(<span class="code">model <span class="string">""</span> <span class="keyword">:type</span> string</span>)</span>
                             <span class="paren3">(<span class="code">year 0 <span class="keyword">:type</span> fixnum</span>)</span></span>)</span></span>)</span>
cl-user&gt; <span class="paren1">(<span class="code">.car <span class="keyword">:company</span> <span class="string">"Ford"</span> <span class="keyword">:model</span> <span class="string">"Mustang"</span> <span class="keyword">:year</span> 1967</span>)</span>
<span class="paren1">(<span class="code">.CAR <span class="string">"Ford"</span> <span class="string">"Mustang"</span> 1967</span>)</span></span></code></pre>

<h2>7.4</h2>

<pre><code><span class="code"><span class="keyword">data</span> <span class="variable">Maybe</span> a <span class="keyword">=</span> <span class="variable">Nothing</span> <span class="keyword">|</span> <span class="variable">Just</span> a

<span class="function">ghci</span><span class="atom">&gt;</span> <span class="variable">Just</span> 3 <span class="keyword">::</span> <span class="variable">Maybe</span> <span class="variable">Int</span>
<span class="variable">Just</span> 3

<span class="keyword">data</span> <span class="variable">IntMaybe</span> <span class="keyword">=</span> <span class="variable">INothing</span> <span class="keyword">|</span> <span class="variable">IJust</span> <span class="variable">Int</span>
<span class="keyword">data</span> <span class="variable">StringMaybe</span> <span class="keyword">=</span> <span class="variable">SNothing</span> <span class="keyword">|</span> <span class="variable">SJust</span> <span class="variable">String</span>
<span class="keyword">data</span> <span class="variable">ShapeMaybe</span> <span class="keyword">=</span> <span class="variable">ShNothing</span> <span class="keyword">|</span> <span class="variable">ShJust</span> <span class="variable">Shape</span></span></code></pre>

<p>上記Haskellにおける型変数は、Common Lispに於ける<code>DEFTYPE</code>の引数と解釈できる。
また、無引数の型コンストラクタはそれ自身を表すものであると解釈できるので、Common Lispに於けるキーワードシンボルであると解釈できる。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">deftype</span></i> maybe<span class="paren2">(<span class="code">a</span>)</span>
  `<span class="paren2">(<span class="code">or <span class="paren3">(<span class="code">eql <span class="keyword">:nothing</span></span>)</span> ,<span class="paren3">(<span class="code">cons-type-specifier '<span class="paren4">(<span class="code">eql just</span>)</span>a</span>)</span></span>)</span></span>)</span>
<span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> just<span class="paren2">(<span class="code">a</span>)</span>
  <span class="paren2">(<span class="code">list 'just a</span>)</span></span>)</span></span></code></pre>

<p>ではこれも<code>DEFDATA</code>マクロに統合しよう。</p>

<pre><code><span class="code"><span class="comment">;;;; DEFDATA
</span><span class="paren1">(<span class="code"><i><span class="symbol">defmacro</span></i> <i><span class="symbol">defdata</span></i><span class="paren2">(<span class="code">name lambda-list &amp;rest constructor*</span>)</span>
  `<span class="paren2">(<span class="code"><i><span class="symbol">EVAL-WHEN</span></i><span class="paren3">(<span class="code"><span class="keyword">:COMPILE-TOPLEVEL</span> <span class="keyword">:LOAD-TOPLEVEL</span> <span class="keyword">:EXECUTE</span></span>)</span>
     ,<span class="paren3">(<span class="code">&lt;<i><span class="symbol">deftype&gt;</span></i> name lambda-list constructor*</span>)</span>
     ,@<span class="paren3">(<span class="code">mapcan #`<span class="paren4">(<span class="code">% '&lt;constructors&gt; name lambda-list</span>)</span>constructor*</span>)</span>
     ,@<span class="paren3">(<span class="code">mapcan #'&lt;pattern-matcher&gt; constructor*</span>)</span>
     ',name</span>)</span></span>)</span>

<span class="comment">;;; &lt;deftype&gt;
</span><span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> &lt;<i><span class="symbol">deftype&gt;</span></i><span class="paren2">(<span class="code">name lambda-list constructor*</span>)</span>
  <span class="paren2">(<span class="code"><i><span class="symbol">labels</span></i><span class="paren3">(<span class="code"><span class="paren4">(<span class="code">optional-lambda-list<span class="paren5">(<span class="code">list</span>)</span>
            <span class="paren5">(<span class="code"><i><span class="symbol">if</span></i><span class="paren6">(<span class="code">cdr list</span>)</span>
              <span class="paren6">(<span class="code">list* <span class="paren1">(<span class="code">car list</span>)</span> '&amp;optional <span class="paren1">(<span class="code">cdr list</span>)</span></span>)</span>
              list</span>)</span></span>)</span>
          <span class="paren4">(<span class="code">type-name<span class="paren5">(<span class="code">args constructor</span>)</span>
            <span class="paren5">(<span class="code"><i><span class="symbol">cond</span></i>
              <span class="paren6">(<span class="code"><span class="paren1">(<span class="code">keywordp constructor</span>)</span>`'<span class="paren1">(<span class="code">EQL ,constructor</span>)</span></span>)</span>
              <span class="paren6">(<span class="code">args <span class="paren1">(<span class="code">comma-type-specifier args constructor</span>)</span></span>)</span>
              <span class="paren6">(<span class="code"><span class="paren1">(<span class="code">list-constructor-p constructor</span>)</span>
               `',<span class="paren1">(<span class="code">cons-type-specifier `<span class="paren2">(<span class="code"><span class="paren3">(<span class="code">eql ,<span class="paren4">(<span class="code">car constructor</span>)</span></span>)</span> ,@<span class="paren3">(<span class="code">cdr constructor</span>)</span></span>)</span></span>)</span></span>)</span>
              <span class="paren6">(<span class="code">t `',<span class="paren1">(<span class="code">cons-type-specifier
                      `<span class="paren2">(<span class="code"><span class="paren3">(<span class="code">eql ,<span class="paren4">(<span class="code">car constructor</span>)</span></span>)</span>
                        ,@<span class="paren3">(<span class="code"><i><span class="symbol">loop</span></i> <span class="keyword">:for</span> clause <span class="keyword">:in</span> <span class="paren4">(<span class="code">cdr constructor</span>)</span>
                                <span class="keyword">:collect</span> <span class="paren4">(<span class="code">or <span class="paren5">(<span class="code">getf clause <span class="keyword">:type</span></span>)</span>
                                             T</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>
    `<span class="paren3">(<span class="code"><i><span class="symbol">DEFTYPE</span></i>,name,<span class="paren4">(<span class="code">optional-lambda-list lambda-list</span>)</span>
       <span class="paren4">(<span class="code">LIST 'OR ,@<span class="paren5">(<span class="code">mapcar <span class="paren6">(<span class="code"><i><span class="symbol">lambda</span></i><span class="paren1">(<span class="code">constructor</span>)</span>
                             <span class="paren1">(<span class="code">type-name lambda-list constructor</span>)</span></span>)</span>
                           constructor*</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>

<span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> comma-type-specifier<span class="paren2">(<span class="code">args constructor</span>)</span>
  ``<span class="paren2">(<span class="code">cons <span class="paren3">(<span class="code">eql ,',<span class="paren4">(<span class="code">car constructor</span>)</span></span>)</span>
         ,,<span class="paren3">(<span class="code"><i><span class="symbol">labels</span></i><span class="paren4">(<span class="code"><span class="paren5">(<span class="code">rec<span class="paren6">(<span class="code">types</span>)</span>
                    <span class="paren6">(<span class="code"><i><span class="symbol">if</span></i><span class="paren1">(<span class="code">endp types</span>)</span>
                      ''null
                      `<span class="paren1">(<span class="code">list 'cons ,<span class="paren2">(<span class="code"><i><span class="symbol">let</span></i><span class="paren3">(<span class="code"><span class="paren4">(<span class="code">arg<span class="paren5">(<span class="code">car types</span>)</span></span>)</span></span>)</span>
                                      <span class="paren3">(<span class="code"><i><span class="symbol">cond</span></i>
                                        <span class="paren4">(<span class="code"><span class="paren5">(<span class="code">find arg args <span class="keyword">:test</span> #'eq</span>)</span>arg</span>)</span>
                                        <span class="paren4">(<span class="code"><span class="paren5">(<span class="code">millet:type-specifier-p arg</span>)</span>`',arg</span>)</span>
                                        <span class="paren4">(<span class="code">t
                                          `<span class="paren5">(<span class="code">list ',<span class="paren6">(<span class="code">car arg</span>)</span> ,@<span class="paren6">(<span class="code">cdr arg</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>
                             ,<span class="paren2">(<span class="code">rec <span class="paren3">(<span class="code">cdr types</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>
            <span class="paren4">(<span class="code">rec <span class="paren5">(<span class="code">cdr constructor</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>

<span class="comment">;;; &lt;costructors&gt;
</span><span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> &lt;constructors&gt;<span class="paren2">(<span class="code">name args constructor</span>)</span>
  <span class="paren2">(<span class="code"><i><span class="symbol">labels</span></i><span class="paren3">(<span class="code"><span class="paren4">(<span class="code">arg-types<span class="paren5">(<span class="code">lambda-list arg-types &amp;optional acc</span>)</span>
            <span class="paren5">(<span class="code"><i><span class="symbol">if</span></i><span class="paren6">(<span class="code">endp arg-types</span>)</span>
              <span class="paren6">(<span class="code">nreverse acc</span>)</span>
              <span class="paren6">(<span class="code"><i><span class="symbol">if</span></i><span class="paren1">(<span class="code">find<span class="paren2">(<span class="code">car arg-types</span>)</span>lambda-list <span class="keyword">:test</span> #'eq</span>)</span>
                <span class="paren1">(<span class="code">arg-types lambda-list <span class="paren2">(<span class="code">cdr arg-types</span>)</span><span class="paren2">(<span class="code">push t acc</span>)</span></span>)</span>
                <span class="paren1">(<span class="code">arg-types lambda-list <span class="paren2">(<span class="code">cdr arg-types</span>)</span><span class="paren2">(<span class="code">push <span class="paren3">(<span class="code">car arg-types</span>)</span>acc</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>
    <span class="paren3">(<span class="code"><i><span class="symbol">cond</span></i>
      <span class="paren4">(<span class="code"><span class="paren5">(<span class="code">keywordp constructor</span>)</span> nil</span>)</span>
      <span class="paren4">(<span class="code"><span class="paren5">(<span class="code">or args <span class="paren6">(<span class="code">list-constructor-p constructor</span>)</span></span>)</span>
       <span class="paren5">(<span class="code"><i><span class="symbol">let</span></i><span class="paren6">(<span class="code"><span class="paren1">(<span class="code">lambda-list<span class="paren2">(<span class="code">gensyms<span class="paren3">(<span class="code">cdr constructor</span>)</span></span>)</span></span>)</span></span>)</span>
         `<span class="paren6">(<span class="code">,@<span class="paren1">(<span class="code"><i><span class="symbol">if</span></i> args
               `<span class="paren2">(<span class="code"><span class="paren3">(<span class="code">DECLAIM<span class="paren4">(<span class="code">FTYPE <span class="paren5">(<span class="code"><i><span class="symbol">FUNCTION</span></i> ,<span class="paren6">(<span class="code">arg-types args <span class="paren1">(<span class="code">cdr constructor</span>)</span></span>)</span>
                                          ,<span class="paren6">(<span class="code">constructor-return-type name</span>)</span></span>)</span>
                                ,<span class="paren5">(<span class="code">car constructor</span>)</span></span>)</span></span>)</span></span>)</span>
               `<span class="paren2">(<span class="code"><span class="paren3">(<span class="code">DECLAIM<span class="paren4">(<span class="code">FTYPE <span class="paren5">(<span class="code"><i><span class="symbol">FUNCTION</span></i>,<span class="paren6">(<span class="code">cdr constructor</span>)</span>,name</span>)</span>
                                ,<span class="paren5">(<span class="code">car constructor</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>
            <span class="paren1">(<span class="code"><i><span class="symbol">DEFUN</span></i> ,<span class="paren2">(<span class="code">car constructor</span>)</span>,lambda-list
              <span class="paren2">(<span class="code">LIST ',<span class="paren3">(<span class="code">car constructor</span>)</span>,@lambda-list</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>
      <span class="paren4">(<span class="code">t `<span class="paren5">(<span class="code"><span class="paren6">(<span class="code"><i><span class="symbol">DEFSTRUCT</span></i><span class="paren1">(<span class="code">,<span class="paren2">(<span class="code">car constructor</span>)</span>
                       <span class="keyword">:NAMED</span> <span class="paren2">(<span class="code"><span class="keyword">:TYPE</span> LIST</span>)</span> <span class="paren2">(<span class="code"><span class="keyword">:CONC-NAME</span> NIL</span>)</span>
                       <span class="paren2">(<span class="code"><span class="keyword">:COPIER</span> NIL</span>)</span> <span class="paren2">(<span class="code"><span class="keyword">:PREDICATE</span> NIL</span>)</span>
                       <span class="paren2">(<span class="code"><span class="keyword">:CONSTRUCTOR</span> ,<span class="paren3">(<span class="code">car constructor</span>)</span></span>)</span></span>)</span>
             ,@<span class="paren1">(<span class="code">cdr constructor</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>

<span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> constructor-return-type<span class="paren2">(<span class="code">name</span>)</span>
  <span class="paren2">(<span class="code">list name '*</span>)</span></span>)</span>

<span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> gensyms <span class="paren2">(<span class="code">list</span>)</span>
  <span class="paren2">(<span class="code"><i><span class="symbol">loop</span></i> <span class="keyword">:repeat</span> <span class="paren3">(<span class="code">length list</span>)</span>
        <span class="keyword">:collect</span> <span class="paren3">(<span class="code">gensym</span>)</span></span>)</span></span>)</span></span></code></pre>

<p>これで以下のようにも書ける。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">defdata</span></i> maybe <span class="paren2">(<span class="code">a</span>)</span>
  <span class="keyword">:nothing</span>
  <span class="paren2">(<span class="code">just a</span>)</span></span>)</span></span></code></pre>

<p>なお、APIが変ったので注意。
冒頭の<code>SHAPE</code>の例は以下のように書かねばならなくなる。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">defdata</span></i> shape <span class="paren2">(<span class="code"></span>)</span>
  <span class="paren2">(<span class="code">circle real real real</span>)</span>
  <span class="paren2">(<span class="code">rectangle real real real real</span>)</span></span>)</span></span></code></pre>

<p>Haskellのシンタックスからは遠のくが、CLer的には馴染みのあるシンタックスになったかと思う。</p>

<h3>Vector</h3>

<pre><code><span class="code"><span class="keyword">data</span> <span class="variable">Vector</span> a <span class="keyword">=</span> <span class="variable">Vector</span> a a a <span class="keyword">deriving</span> <span class="paren1">(<span class="code"><span class="variable">Show</span></span>)</span></span></code></pre>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">defdata</span></i> .vector <span class="paren2">(<span class="code">a</span>)</span>
  <span class="paren2">(<span class="code">.vector a a a</span>)</span></span>)</span></span></code></pre>

<pre><code>vplus :: (Num a) =&gt; Vector a -&gt; Vector a -&gt; Vector a
(Vector i j k) `vplus` (Vector l m n) = Vector (i+l) (j+m) (k+n)

dotProd :: (Num a) =&gt; Vector a -&gt; Vector a -&gt; a
(Vector i j k) `dotProd` (Vector l m n) = (i*l) + (j*m) + (k*n)

vmult :: (Num a) =&gt; Vector a -&gt; a -&gt; Vector a
(Vector i j k) `vmult` m = Vector (i*m) (j*m) (k*m)</code></pre>

<p>上記Haskellコードの<code>(Num a)</code>に相当する型クラス制約は、少々冗長になるが素のCommon Lispで対応可能である。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">declaim<span class="paren2">(<span class="code">ftype<span class="paren3">(<span class="code"><i><span class="symbol">function</span></i><span class="paren4">(<span class="code"><span class="paren5">(<span class="code">.vector number</span>)</span><span class="paren5">(<span class="code">.vector number</span>)</span></span>)</span><span class="paren4">(<span class="code">.vector number</span>)</span></span>)</span>vplus</span>)</span></span>)</span>
<span class="paren1">(<span class="code"><i><span class="symbol">trivia:defun-ematch*</span></i> vplus<span class="paren2">(<span class="code">v1 v2</span>)</span>
  <span class="paren2">(<span class="code"><span class="paren3">(<span class="code"><span class="paren4">(<span class="code">.vector i j k</span>)</span><span class="paren4">(<span class="code">.vector l m n</span>)</span></span>)</span><span class="paren3">(<span class="code">.vector<span class="paren4">(<span class="code">+ i l</span>)</span><span class="paren4">(<span class="code">+ j m</span>)</span><span class="paren4">(<span class="code">+ k n</span>)</span></span>)</span></span>)</span></span>)</span>

<span class="paren1">(<span class="code">declaim<span class="paren2">(<span class="code">ftype<span class="paren3">(<span class="code"><i><span class="symbol">function</span></i><span class="paren4">(<span class="code"><span class="paren5">(<span class="code">.vector number</span>)</span><span class="paren5">(<span class="code">.vector number</span>)</span></span>)</span>number</span>)</span>dot-prod</span>)</span></span>)</span>
<span class="paren1">(<span class="code"><i><span class="symbol">trivia:defun-ematch*</span></i> dot-prod<span class="paren2">(<span class="code">v1 v2</span>)</span>
  <span class="paren2">(<span class="code"><span class="paren3">(<span class="code"><span class="paren4">(<span class="code">.vector i j k</span>)</span><span class="paren4">(<span class="code">.vector l m n</span>)</span></span>)</span><span class="paren3">(<span class="code">+ <span class="paren4">(<span class="code">* i l</span>)</span><span class="paren4">(<span class="code">* j m</span>)</span><span class="paren4">(<span class="code">* k n</span>)</span></span>)</span></span>)</span></span>)</span>

<span class="paren1">(<span class="code">declaim<span class="paren2">(<span class="code">ftype<span class="paren3">(<span class="code"><i><span class="symbol">function</span></i><span class="paren4">(<span class="code"><span class="paren5">(<span class="code">.vector number</span>)</span>number</span>)</span><span class="paren4">(<span class="code">.vector number</span>)</span></span>)</span>vmult</span>)</span></span>)</span>
<span class="paren1">(<span class="code"><i><span class="symbol">trivia:defun-ematch*</span></i> vmult <span class="paren2">(<span class="code">v m</span>)</span>
  <span class="paren2">(<span class="code"><span class="paren3">(<span class="code"><span class="paren4">(<span class="code">.vector i j k</span>)</span> m</span>)</span><span class="paren3">(<span class="code">.vector <span class="paren4">(<span class="code">* i m</span>)</span><span class="paren4">(<span class="code">* j m</span>)</span><span class="paren4">(<span class="code">* k m</span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<p>どうしても冗長なのが気になるなら以下のようにマクロを組めば良い。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">defmacro</span></i> .ftype<span class="paren2">(<span class="code">name &amp;rest args</span>)</span>
  <span class="paren2">(<span class="code">multiple-value-bind<span class="paren3">(<span class="code">args return</span>)</span><span class="paren3">(<span class="code">parse-.ftype args</span>)</span>
    `<span class="paren3">(<span class="code">declaim<span class="paren4">(<span class="code">ftype<span class="paren5">(<span class="code"><i><span class="symbol">function</span></i> ,args ,return</span>)</span>,name</span>)</span></span>)</span></span>)</span></span>)</span>

<span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> parse-.ftype<span class="paren2">(<span class="code">args</span>)</span>
  <span class="paren2">(<span class="code"><i><span class="symbol">let</span></i><span class="paren3">(<span class="code"><span class="paren4">(<span class="code">constraint<span class="paren5">(<span class="code">when<span class="paren6">(<span class="code">string= '=&gt; <span class="paren1">(<span class="code">second args</span>)</span></span>)</span>
                    <span class="paren6">(<span class="code">prog1 <span class="paren1">(<span class="code">pop args</span>)</span>
              <span class="paren1">(<span class="code">pop args</span>)</span></span>)</span></span>)</span></span>)</span>
       <span class="paren4">(<span class="code">args<span class="paren5">(<span class="code">delete '-&gt; args <span class="keyword">:test</span> <span class="paren6">(<span class="code"><i><span class="symbol">lambda</span></i><span class="paren1">(<span class="code">a b</span>)</span><span class="paren1">(<span class="code">and <span class="paren2">(<span class="code">symbolp b</span>)</span><span class="paren2">(<span class="code">string= a b</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>
    <span class="paren3">(<span class="code">when constraint
      <span class="paren4">(<span class="code">setf args <span class="paren5">(<span class="code">subst <span class="paren6">(<span class="code">car constraint</span>)</span><span class="paren6">(<span class="code">cadr constraint</span>)</span> args</span>)</span></span>)</span></span>)</span>
    <span class="paren3">(<span class="code">values <span class="paren4">(<span class="code">butlast args</span>)</span>
            <span class="paren4">(<span class="code">car<span class="paren5">(<span class="code">last args</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>

<span class="paren1">(<span class="code">.ftype vplus <span class="paren2">(<span class="code">number a</span>)</span> =&gt; <span class="paren2">(<span class="code">.vector a</span>)</span> -&gt; <span class="paren2">(<span class="code">.vector a</span>)</span> -&gt; <span class="paren2">(<span class="code">.vector a</span>)</span></span>)</span></span></code></pre>

<p>気を付けなければいけない点として、上のマクロはHaskellのシンタックスをなぞって模倣しただけのものであり、そのセマンティクスまでは再現できていないという点である。
すなわち、カリー化された関数となるわけではない。</p>

<h2>7.5</h2>

<h3>deriving</h3>

<h3>Eq</h3>

<pre><code><span class="code"><span class="keyword">data</span> <span class="variable">Person</span> <span class="keyword">=</span> <span class="variable">Person</span> <span class="paren1">{<span class="code"> firstName <span class="keyword">::</span> <span class="variable">String</span>
&nbsp;                    , lastName <span class="keyword">::</span> <span class="variable">String</span>
&nbsp;                    , age <span class="keyword">::</span> <span class="variable">Int</span>
&nbsp;                    </span>}</span> <span class="keyword">deriving</span> <span class="paren1">(<span class="code"><span class="variable">Eq</span></span>)</span>

<span class="function">mikeD</span> <span class="keyword">=</span> <span class="variable">Person</span> <span class="paren1">{<span class="code">firstName <span class="keyword">=</span> <span class="string">"Michael"</span>, lastName <span class="keyword">=</span> <span class="string">"Diamond"</span>, age <span class="keyword">=</span> 43</span>}</span>
<span class="function">adRock</span> <span class="keyword">=</span> <span class="variable">Person</span> <span class="paren1">{<span class="code">firstName <span class="keyword">=</span> <span class="string">"Adam"</span>, lastName <span class="keyword">=</span> <span class="string">"Horovitz"</span>, age <span class="keyword">=</span> 41</span>}</span>
<span class="function">mca</span> <span class="keyword">=</span> <span class="variable">Person</span> <span class="paren1">{<span class="code">firstName <span class="keyword">=</span> <span class="string">"Adam"</span>,lastName <span class="keyword">=</span> <span class="string">"Yauch"</span>,age <span class="keyword">=</span> 44</span>}</span>

<span class="function">ghci</span><span class="atom">&gt;</span> mca <span class="atom">==</span> adRock
<span class="variable">False</span>
<span class="function">ghci</span><span class="atom">&gt;</span> mikeD <span class="atom">==</span> adRock
<span class="variable">False</span>
<span class="function">ghci</span><span class="atom">&gt;</span> mikeD <span class="atom">==</span> mikeD
<span class="variable">True</span>
<span class="function">ghci</span><span class="atom">&gt;</span> mikeD <span class="atom">==</span> <span class="variable">Person</span> <span class="paren1">{<span class="code">firstName<span class="keyword">=</span><span class="string">"Michael"</span>, lastName<span class="keyword">=</span><span class="string">"Diamond"</span>, age<span class="keyword">=</span>43</span>}</span>
<span class="variable">True</span>

<span class="function">ghci</span><span class="atom">&gt;</span> <span class="keyword">let</span> beastieBoys <span class="keyword">=</span> <span class="paren1">[<span class="code">mca, adRock, mikeD</span>)</span>
<span class="function">ghci</span><span class="atom">&gt;</span> mikeD <span class="atom">`elem`</span> beastieBoys
<span class="variable">True</span></span></code></pre>

<p>Haskellに於ける上記<code>deriving</code>キーワードは、Common Lispに於いては現時点では必要ない。
特に指定なくとも<code>EQUAL</code>がそのまま使える。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">defdata</span></i> person <span class="paren2">(<span class="code"></span>)</span>
  <span class="paren2">(<span class="code">person <span class="paren3">(<span class="code">first-name <span class="string">""</span> <span class="keyword">:type</span> string</span>)</span>
          <span class="paren3">(<span class="code">last-name <span class="string">""</span> <span class="keyword">:type</span> string</span>)</span>
          <span class="paren3">(<span class="code">age 0 <span class="keyword">:type</span> fixnum</span>)</span></span>)</span></span>)</span>
<span class="paren1">(<span class="code"><i><span class="symbol">defvar</span></i> mike-d <span class="paren2">(<span class="code">person <span class="keyword">:first-name</span> <span class="string">"Michael"</span> <span class="keyword">:last-name</span> <span class="string">"Diamond"</span> <span class="keyword">:age</span> 43</span>)</span></span>)</span>
<span class="paren1">(<span class="code"><i><span class="symbol">defvar</span></i> ad-rock <span class="paren2">(<span class="code">person <span class="keyword">:first-name</span> <span class="string">"Adam"</span> <span class="keyword">:last-name</span> <span class="string">"Horovitz"</span> <span class="keyword">:age</span> 41</span>)</span></span>)</span>
<span class="paren1">(<span class="code"><i><span class="symbol">defvar</span></i> mca <span class="paren2">(<span class="code">person <span class="keyword">:first-name</span> <span class="string">"Adam"</span> <span class="keyword">:last-name</span> <span class="string">"Yauch"</span> <span class="keyword">:age</span> 44</span>)</span></span>)</span>

cl-user&gt; <span class="paren1">(<span class="code">equal mca ad-rock</span>)</span>
NIL
cl-user&gt; <span class="paren1">(<span class="code">equal mike-d ad-rock</span>)</span>
NIL
cl-user&gt; <span class="paren1">(<span class="code">equal mike-d mike-d</span>)</span>
T
cl-user&gt; <span class="paren1">(<span class="code">equal mike-d <span class="paren2">(<span class="code">person <span class="keyword">:first-name</span> <span class="string">"Michael"</span> <span class="keyword">:last-name</span> <span class="string">"Diamond"</span> <span class="keyword">:age</span> 43</span>)</span></span>)</span>
T

cl-user&gt; <span class="paren1">(<span class="code"><i><span class="symbol">defvar</span></i> beastie-boys <span class="paren2">(<span class="code">list mca ad-rock mike-d</span>)</span></span>)</span>
cl-user&gt; <span class="paren1">(<span class="code">find mike-d beastie-boys</span>)</span>
NIL
cl-user&gt; <span class="paren1">(<span class="code">find mike-d beastie-boys <span class="keyword">:test</span> #'equal</span>)</span>
<span class="paren1">(<span class="code">PERSON <span class="string">"Michael"</span> <span class="string">"Diamond"</span> 43</span>)</span></span></code></pre>

<h3>Show Read</h3>

<pre><code><span class="code"><span class="keyword">data</span> <span class="variable">Person</span> <span class="keyword">=</span> <span class="variable">Person</span> <span class="paren1">{<span class="code"> firstName <span class="keyword">::</span> <span class="variable">String</span>
&nbsp;                    , lastName <span class="keyword">::</span> <span class="variable">String</span>
&nbsp;                    , age <span class="keyword">::</span> <span class="variable">Int</span>
&nbsp;                    </span>}</span> <span class="keyword">deriving</span> <span class="paren1">(<span class="code"><span class="variable">Eq,</span> <span class="variable">Show,</span> <span class="variable">Read</span></span>)</span></span></code></pre>

<p>Haskellに於ける上記<code>Show</code>、<code>Read</code>型クラスインスタンスの指定も、Common Lispに於いては現状必要ない。</p>

<pre><code><span class="code"><span class="function">ghci</span><span class="atom">&gt;</span> mikeD
<span class="variable">Person</span> <span class="paren1">{<span class="code">firstName <span class="keyword">=</span> <span class="string">"Michael"</span>, lastName <span class="keyword">=</span> <span class="string">"Diamond"</span>, age <span class="keyword">=</span> 43</span>}</span>
<span class="function">ghci</span><span class="atom">&gt;</span> <span class="string">"mikeD is: "</span> <span class="atom">++</span> <span class="variable">Show</span> mikeD
<span class="string">"mikeD is: Person {firstName = </span><span class="string">\"</span><span class="string">Michael</span><span class="string">\"</span><span class="string">, lastName = </span><span class="string">\"</span><span class="string">Diamond</span><span class="string">\"</span><span class="string">, age = 43}"</span></span></code></pre>

<p>Haskellに於ける<code>Show</code>はCommon Lispではおよそ<code>PRIN1-TO-STRING</code>が相当する。</p>

<pre><code><span class="code">cl-user&gt; mike-d
<span class="paren1">(<span class="code">PERSON <span class="string">"Michael"</span> <span class="string">"Diamond"</span> 43</span>)</span>
cl-user&gt; <span class="paren1">(<span class="code">uiop:strcat <span class="string">"mikeD is: "</span><span class="paren2">(<span class="code">prin1-to-string mike-d</span>)</span></span>)</span>
"mikeD is: <span class="paren1">(<span class="code">PERSON \"Michael\" \"Diamond\" 43</span>)</span>"</span></code></pre>

<p>なお、同様に<code>PRINC-TO-STRING</code>、<code>WRITE-TO-STRING</code>も存在する。
<code>PRINC</code>は人間にとって読みやすい形で表示する。</p>

<pre><code><span class="code">cl-user&gt; <span class="paren1">(<span class="code">princ <span class="keyword">:hoge</span></span>)</span>
HOGE <span class="comment">; &lt;--- side effect
</span>:HOGE <span class="comment">; &lt;--- return value
</span>cl-user&gt; <span class="paren1">(<span class="code">princ <span class="string">"hoge"</span></span>)</span>
hoge <span class="comment">; &lt;--- side effect
</span>"hoge" <span class="comment">; &lt;--- return value</span></span></code></pre>

<p><code>WRITE</code>は動的にスペシャル変数の影響を受ける。</p>

<pre><code><span class="code">cl-user&gt; <span class="paren1">(<span class="code"><i><span class="symbol">let</span></i><span class="paren2">(<span class="code"><span class="paren3">(<span class="code"><span class="special">*print-escape*</span> t</span>)</span></span>)</span>
           <span class="paren2">(<span class="code">write <span class="keyword">:hoge</span></span>)</span></span>)</span>
:HOGE
:HOGE
cl-user&gt; <span class="paren1">(<span class="code"><i><span class="symbol">let</span></i><span class="paren2">(<span class="code"><span class="paren3">(<span class="code"><span class="special">*print-escape*</span> nil</span>)</span></span>)</span>
           <span class="paren2">(<span class="code">write <span class="keyword">:hoge</span></span>)</span></span>)</span>
HOGE
:HOGE</span></code></pre>

<pre><code><span class="code"><span class="function">mysteryDude</span> <span class="keyword">=</span> <span class="string">"Person { firstName = </span><span class="string">\"</span><span class="string">Michael</span><span class="string">\"</span><span class="string">, lastName = </span><span class="string">\"</span><span class="string">Diamond</span><span class="string">\"</span><span class="string">, age = 43}"</span>
<span class="function">ghci</span><span class="atom">&gt;</span> read mysteryDude <span class="keyword">::</span> <span class="variable">Person</span>
<span class="variable">Person</span> <span class="paren1">{<span class="code">firstName <span class="keyword">=</span> <span class="string">"Michael"</span>, lastName <span class="keyword">=</span> <span class="string">"Diamond"</span>, age <span class="keyword">=</span> 43</span>}</span></span></code></pre>

<p>Haskellに於ける<code>read</code>はCommon Lispに於ける<code>READ-FROM-STRING</code>に相当する。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">defvar</span></i> mystery-dude <span class="string">"#.(person :first-name </span><span class="string">\"</span><span class="string">Michael</span><span class="string">\"</span><span class="string"> :last-name </span><span class="string">\"</span><span class="string">Diamond</span><span class="string">\"</span><span class="string"> :age 43)"</span></span>)</span>
cl-user&gt; <span class="paren1">(<span class="code">read-from-string mystery-dude</span>)</span>
<span class="paren1">(<span class="code">PERSON <span class="string">"Michael"</span> <span class="string">"Diamond"</span> 43</span>)</span>
61</span></code></pre>

<p>第ニ返り値の<code>61</code>は消費した文字数である。</p>

<p>文字列の先頭に<code>#.</code>が指定されている点要注意。
これがなければ以下のような不正なデータ型になってしまう。</p>

<pre><code><span class="code">cl-user&gt; <span class="paren1">(<span class="code">read-from-string <span class="string">"(person :first-name </span><span class="string">\"</span><span class="string">Michael</span><span class="string">\"</span><span class="string"> :last-name </span><span class="string">\"</span><span class="string">Diamond</span><span class="string">\"</span><span class="string"> :age 43)"</span></span>)</span>
<span class="paren1">(<span class="code">PERSON <span class="keyword">:FIRST-NAME</span> <span class="string">"Michael"</span> <span class="keyword">:LAST-NAME</span> <span class="string">"Diamond"</span> <span class="keyword">:AGE</span> 43</span>)</span>
59</span></code></pre>

<h3>Order</h3>

<pre><code><span class="code"><span class="keyword">data</span> <span class="variable">Bool</span> <span class="keyword">=</span> <span class="variable">Fails</span> <span class="keyword">|</span> <span class="variable">True</span> <span class="keyword">deriving</span> <span class="paren1">(<span class="code"><span class="variable">Ord</span></span>)</span>

<span class="function">ghci</span><span class="atom">&gt;</span> <span class="variable">True</span> <span class="atom">`compare`</span> <span class="variable">False</span>
<span class="variable">GT</span>
<span class="function">ghci</span><span class="atom">&gt;</span> <span class="variable">True</span> <span class="atom">&gt;</span> <span class="variable">False</span>
<span class="variable">True</span>
<span class="function">ghci</span><span class="atom">&gt;</span> <span class="variable">True</span> <span class="atom">&lt;</span> <span class="variable">False</span>
<span class="variable">False</span></span></code></pre>

<p>上記Haskellに於ける<code>compare</code>とその背後にある仕組みは、Common Lispには存在しない。</p>

<p><code>DEFDATA</code>マクロに組み込もう。</p>

<pre><code><span class="code"><span class="comment">;;;; DEFDATA
</span><span class="paren1">(<span class="code"><i><span class="symbol">defmacro</span></i> <i><span class="symbol">defdata</span></i><span class="paren2">(<span class="code">name lambda-list &amp;rest constructor*</span>)</span>
  `<span class="paren2">(<span class="code"><i><span class="symbol">eval-when</span></i><span class="paren3">(<span class="code"><span class="keyword">:compile-toplevel</span> <span class="keyword">:load-toplevel</span> <span class="keyword">:execute</span></span>)</span>
     ,<span class="paren3">(<span class="code">&lt;<i><span class="symbol">deftype&gt;</span></i> name lambda-list constructor*</span>)</span>
     <span class="paren3">(<span class="code">SETF<span class="paren4">(<span class="code">GET ',name 'ADT</span>)</span>T</span>)</span>
     ,@<span class="paren3">(<span class="code">mapcan #`<span class="paren4">(<span class="code">% #'&lt;constructors&gt; name lambda-list</span>)</span>constructor*</span>)</span>
     ,@<span class="paren3">(<span class="code"><i><span class="symbol">loop</span></i> <span class="keyword">:for</span> c <span class="keyword">:in</span> constructor*
             <span class="keyword">:for</span> o <span class="keyword">:upfrom</span> 0
             <span class="keyword">:collect</span> <span class="paren4">(<span class="code">&lt;meta-info-setter&gt; c o lambda-list name</span>)</span></span>)</span>
     ,@<span class="paren3">(<span class="code">mapcan #'&lt;pattern-matcher&gt; constructor*</span>)</span>
     ',name</span>)</span></span>)</span>

<span class="comment">;;;; ADT data structure
</span><span class="paren1">(<span class="code"><i><span class="symbol">defstruct</span></i><span class="paren2">(<span class="code">adt <span class="paren3">(<span class="code"><span class="keyword">:copier</span> nil</span>)</span><span class="paren3">(<span class="code"><span class="keyword">:predicate</span> nil</span>)</span></span>)</span>
  <span class="paren2">(<span class="code">order <span class="paren3">(<span class="code">error <span class="string">"required"</span></span>)</span> <span class="keyword">:type</span> fixnum <span class="keyword">:read-only</span> t</span>)</span></span>)</span>

<span class="comment">;;; &lt;meta-info-setter&gt;
</span><span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> &lt;meta-info-setter&gt;<span class="paren2">(<span class="code">constructor order lambda-list name</span>)</span>
  <span class="paren2">(<span class="code"><i><span class="symbol">let</span></i><span class="paren3">(<span class="code"><span class="paren4">(<span class="code">c <span class="paren5">(<span class="code">alexandria:ensure-car constructor</span>)</span></span>)</span></span>)</span>
    `<span class="paren3">(<span class="code">SETF <span class="paren4">(<span class="code">GET ',c 'adt-meta-info</span>)</span>
           <span class="paren4">(<span class="code">MAKE-ADT <span class="keyword">:ORDER</span> ,order</span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<p><code>compare</code>の実装は後述。</p>

<h3>week</h3>

<pre><code><span class="code"><span class="keyword">data</span> <span class="variable">Day</span> <span class="keyword">=</span> <span class="variable">Monday</span> <span class="keyword">|</span> <span class="variable">Tuesday</span> <span class="keyword">|</span> <span class="variable">Wednesday</span> <span class="keyword">|</span> <span class="variable">Thursday</span> <span class="keyword">|</span> <span class="variable">Friday</span> <span class="keyword">|</span> <span class="variable">Saturday</span> <span class="keyword">|</span> <span class="variable">Sunday</span>
&nbsp;            <span class="keyword">deriving</span> <span class="paren1">(<span class="code"><span class="variable">Eq,</span> <span class="variable">Ord,</span> <span class="variable">Show,</span> <span class="variable">Read,</span> <span class="variable">Bounded,</span> <span class="variable">Enum</span></span>)</span>

<span class="function">ghci</span><span class="atom">&gt;</span> <span class="variable">Wednesday</span>
<span class="variable">Wednesday</span>
<span class="function">ghci</span><span class="atom">&gt;</span> show <span class="variable">Wednesday</span>
<span class="string">"Wednesday"</span>
<span class="function">ghci</span><span class="atom">&gt;</span> read <span class="string">"Saturday"</span> <span class="keyword">::</span> <span class="variable">Day</span>
<span class="variable">Saturday</span>

<span class="function">ghci</span><span class="atom">&gt;</span> <span class="variable">Saturday</span> <span class="atom">==</span> <span class="variable">Sunday</span>
<span class="variable">False</span>
<span class="function">ghci</span><span class="atom">&gt;</span> <span class="variable">Saturday</span> <span class="atom">==</span> <span class="variable">Saturday</span>
<span class="variable">True</span>
<span class="function">ghci</span><span class="atom">&gt;</span> <span class="variable">Saturday</span> <span class="atom">&gt;</span> <span class="variable">Friday</span>
<span class="variable">True</span>
<span class="function">ghci</span><span class="atom">&gt;</span> <span class="variable">Monday</span> <span class="atom">`compare`</span> <span class="variable">Wednesday</span>
<span class="variable">LT</span>

<span class="function">ghci</span><span class="atom">&gt;</span> minBound <span class="keyword">::</span> <span class="variable">Day</span>
<span class="variable">Monday</span>
<span class="function">ghci</span><span class="atom">&gt;</span> maxBound <span class="keyword">::</span> <span class="variable">Day</span>
<span class="variable">Sunday</span>

<span class="function">ghci</span><span class="atom">&gt;</span> succ <span class="variable">Monday</span>
<span class="variable">Tuesday</span>
<span class="function">ghci</span><span class="atom">&gt;</span> pred <span class="variable">Saturday</span>
<span class="variable">Friday</span>
<span class="function">ghci</span><span class="atom">&gt;</span> <span class="paren1">[<span class="code"><span class="variable">Thursday</span><span class="keyword">..</span><span class="variable">Sunday</span></span>)</span>
<span class="paren1">[<span class="code"><span class="variable">Thursday,Friday,Saturday,Sunday</span></span>)</span>
<span class="function">ghci</span><span class="atom">&gt;</span> <span class="paren1">[<span class="code">minBound <span class="keyword">..</span> maxBound</span>)</span> <span class="keyword">::</span> <span class="paren1">[<span class="code"><span class="variable">Day</span></span>)</span>
<span class="paren1">[<span class="code"><span class="variable">Monday,Tuesday,Wednesday,Thursday,Friday,Saturday,Sunday</span></span>)</span></span></code></pre>

<p>こいつも後に譲る。</p>

<h2>7.6</h2>

<h3>Type synonym</h3>

<pre><code><span class="code"><span class="keyword">type</span> <span class="variable">String</span> <span class="keyword">=</span> <span class="paren1">[<span class="code"><span class="variable">Char</span></span>]</span></span></code></pre>

<p>上記Haskellコードに於ける型シノニムの機能は、Common Lispに於ける<code>DEFTYPE</code>のそれである。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">deftype</span></i> string <span class="paren2">(<span class="code"></span>)</span>'<span class="paren2">(<span class="code">vector character</span>)</span></span>)</span></span></code></pre>

<h3>Phone book</h3>

<pre><code><span class="code"><span class="keyword">type</span> <span class="variable">PhoneNumber</span> <span class="keyword">=</span> <span class="variable">String</span>
<span class="keyword">type</span> <span class="variable">Name</span> <span class="keyword">=</span> <span class="variable">String</span>
<span class="keyword">type</span> phoneBook <span class="keyword">=</span> <span class="paren1">[<span class="code"><span class="paren2">(<span class="code"><span class="variable">Name,</span> <span class="variable">PhoneNumber</span></span>)</span></span>]</span></span></code></pre>

<p>Haskellに於ける上記コードをCommon Lispに翻訳するには少々迂遠な道程を辿らねばならない。
というのも、同一の型からなるリストを表す簡単な方法が無いからだ。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">deftype</span></i> phone-number<span class="paren2">(<span class="code"></span>)</span>'string</span>)</span>
<span class="paren1">(<span class="code"><i><span class="symbol">deftype</span></i> name<span class="paren2">(<span class="code"></span>)</span>'string</span>)</span>
<span class="paren1">(<span class="code"><i><span class="symbol">deftype</span></i> phone-book<span class="paren2">(<span class="code"></span>)</span>
  '<span class="paren2">(<span class="code">satisfies phone-bookp</span>)</span></span>)</span>
<span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> phone-bookp<span class="paren2">(<span class="code">arg</span>)</span>
  <span class="paren2">(<span class="code">and <span class="paren3">(<span class="code">listp arg</span>)</span>
       <span class="paren3">(<span class="code">ignore-errors <span class="paren4">(<span class="code">every <span class="paren5">(<span class="code"><i><span class="symbol">lambda</span></i><span class="paren6">(<span class="code">elt</span>)</span>
                               <span class="paren6">(<span class="code">and <span class="paren1">(<span class="code">consp elt</span>)</span>
                                    <span class="paren1">(<span class="code">typep <span class="paren2">(<span class="code">car elt</span>)</span>'name</span>)</span>
                                    <span class="paren1">(<span class="code">typep <span class="paren2">(<span class="code">cdr elt</span>)</span>'phone-number</span>)</span></span>)</span></span>)</span>
                             arg</span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<pre><code><span class="code"><span class="function">inPhoneBook</span> <span class="keyword">::</span> <span class="variable">Name</span> <span class="keyword">-&gt;</span> <span class="variable">PhoneNumber</span> <span class="keyword">-&gt;</span> <span class="variable">PhoneBook</span> <span class="keyword">-&gt;</span> <span class="variable">Bool</span>
<span class="function">inPhoneBook</span> name pnumber pbook <span class="keyword">=</span> <span class="paren1">(<span class="code">name, pnumber</span>)</span> <span class="atom">`elem`</span> pbook</span></code></pre>

<pre><code><span class="code"><span class="paren1">(<span class="code">declaim<span class="paren2">(<span class="code">ftype<span class="paren3">(<span class="code"><i><span class="symbol">function</span></i><span class="paren4">(<span class="code">name phone-number phone-book</span>)</span>boolean</span>)</span>in-phone-book-p</span>)</span></span>)</span>
<span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> in-phone-book-p<span class="paren2">(<span class="code">name pnumber pbook</span>)</span>
  <span class="paren2">(<span class="code">find <span class="paren3">(<span class="code">cons name pnumber</span>)</span> pbook <span class="keyword">:test</span> #'equal</span>)</span></span>)</span></span></code></pre>

<h3>Complex synonym</h3>

<pre><code><span class="code"><span class="keyword">type</span> <span class="variable">AssocList</span> k v <span class="keyword">=</span> <span class="paren1">[<span class="code"><span class="paren2">(<span class="code">k,v</span>)</span></span>]</span></span></code></pre>

<p>前節でも述べた通り、Common Lispでは同一の型からなるリストを表す簡単な方法はない。
上記Haskellコードと等価なものはCommon Lispでは書けない。
というのも、<code>SATISFIES</code>の引数はシンボルでなくてはならないからだ。
すなわち、引数を渡す手段がない。</p>

<p>Common Lispに於いては、リストというものは様々な型のオブジェクトを任意個格納するためのもの、と割り切っているように見える。
なお、Common Lispに於いては、同様の型のオブジェクトを任意個格納するためのものとして<code>SIMPLE-VECTOR</code>が想定されているようだ。
例えば、上記haskellコードは、<code>VECTOR</code>を使えばCommon Lispで以下のように書ける。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">deftype</span></i> assoc-vector<span class="paren2">(<span class="code">k v</span>)</span>
  `<span class="paren2">(<span class="code">vector <span class="paren3">(<span class="code">cons ,k ,v</span>)</span></span>)</span></span>)</span></span></code></pre>

<h3>Either</h3>

<pre><code><span class="code"><span class="keyword">data</span> either a b <span class="keyword">=</span> <span class="variable">Left</span> a <span class="keyword">|</span> <span class="variable">Right</span> b <span class="keyword">deriving</span> <span class="paren1">(<span class="code"><span class="variable">Eq,</span> <span class="variable">Ord,</span> <span class="variable">Read,</span> <span class="variable">Show</span></span>)</span></span></code></pre>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">defdata</span></i> either <span class="paren2">(<span class="code">a b</span>)</span>
  <span class="paren2">(<span class="code">left a</span>)</span>
  <span class="paren2">(<span class="code">right b</span>)</span></span>)</span></span></code></pre>

<pre><code><span class="code"><span class="keyword">data</span> <span class="variable">LockerState</span> <span class="keyword">=</span> <span class="variable">Taken</span> <span class="keyword">|</span> <span class="variable">Free</span> <span class="keyword">deriving</span> <span class="paren1">(<span class="code"><span class="variable">Show,</span> <span class="variable">Eq</span></span>)</span>

<span class="keyword">type</span> <span class="variable">Code</span> <span class="keyword">=</span> <span class="variable">String</span>

<span class="keyword">type</span> <span class="variable">LockerMap</span> <span class="keyword">=</span> <span class="variable">Map</span><span class="atom">.</span><span class="variable">Map</span> <span class="variable">Int</span> <span class="paren1">(<span class="code"><span class="variable">LockerState,</span> <span class="variable">Code</span></span>)</span>

<span class="function">lockerLookup</span> <span class="keyword">::</span> <span class="variable">Int</span> <span class="keyword">-&gt;</span> <span class="variable">LockerMap</span> <span class="keyword">-&gt;</span> <span class="variable">Either</span> <span class="variable">String</span> <span class="variable">Code</span>
<span class="function">lockerLookup</span> lockerNumber map <span class="keyword">=</span> <span class="keyword">case</span> <span class="variable">Map</span><span class="atom">.</span>lookup lockerNumber map <span class="keyword">of</span>
&nbsp;   <span class="variable">Nothing</span> <span class="keyword">-&gt;</span> <span class="variable">Left</span> <span class="atom">$</span> <span class="string">"Locker "</span> <span class="atom">++</span> show lockerNumber <span class="atom">++</span> <span class="string">" doesn't exist!"</span>
&nbsp;   <span class="variable">Just</span> <span class="paren1">(<span class="code">state, code</span>)</span> <span class="keyword">-&gt;</span> <span class="keyword">if</span> state <span class="atom">/=</span> <span class="variable">Taken</span>
&nbsp;                            <span class="keyword">then</span> <span class="variable">Right</span> code
&nbsp;                            <span class="keyword">else</span> <span class="variable">Left</span> <span class="atom">$</span> <span class="string">"Locker "</span> <span class="atom">++</span> shoe lockerNumber <span class="atom">++</span> <span class="string">" is already taken!"</span></span></code></pre>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">defdata</span></i> locker-state <span class="paren2">(<span class="code"></span>)</span> <span class="keyword">:taken</span> <span class="keyword">:free</span></span>)</span>
<span class="paren1">(<span class="code"><i><span class="symbol">deftype</span></i> code <span class="paren2">(<span class="code"></span>)</span> 'string</span>)</span>
<span class="paren1">(<span class="code"><i><span class="symbol">deftype</span></i> locker-map<span class="paren2">(<span class="code"></span>)</span>'hash-table</span>)</span>

<span class="paren1">(<span class="code">declaim<span class="paren2">(<span class="code">ftype<span class="paren3">(<span class="code"><i><span class="symbol">function</span></i><span class="paren4">(<span class="code">fixnum locker-map</span>)</span><span class="paren4">(<span class="code">either string code</span>)</span></span>)</span>loker-lookup</span>)</span></span>)</span>
<span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> locker-lookup<span class="paren2">(<span class="code">locker-number map</span>)</span>
  <span class="paren2">(<span class="code">multiple-value-bind<span class="paren3">(<span class="code">key exist?</span>)</span><span class="paren3">(<span class="code">gethash locker-number map</span>)</span>
    <span class="paren3">(<span class="code"><i><span class="symbol">if</span></i> exist?
      <span class="paren4">(<span class="code">destructuring-bind<span class="paren5">(<span class="code">state . code</span>)</span>key
        <span class="paren5">(<span class="code"><i><span class="symbol">if</span></i> <span class="paren6">(<span class="code">not<span class="paren1">(<span class="code">eq state <span class="keyword">:taken</span></span>)</span></span>)</span>
          <span class="paren6">(<span class="code">right code</span>)</span>
          <span class="paren6">(<span class="code">left <span class="paren1">(<span class="code">uiop:strcat <span class="string">"Locker "</span> <span class="paren2">(<span class="code">princ-to-string locker-number</span>)</span> <span class="string">" is already taken!"</span></span>)</span></span>)</span></span>)</span></span>)</span>
      <span class="paren4">(<span class="code">left<span class="paren5">(<span class="code">uiop:strcat <span class="string">"Locker "</span> <span class="paren6">(<span class="code">princ-to-string locker-number</span>)</span> <span class="string">" doesn't exist!"</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<h2>7.7</h2>

<h3>Recursive data type</h3>

<pre><code><span class="code"><span class="keyword">data</span> <span class="variable">List</span> a <span class="keyword">=</span> <span class="variable">Empty</span> <span class="keyword">|</span> <span class="variable">Cons</span> a <span class="paren1">(<span class="code"><span class="variable">List</span> a</span>)</span> <span class="keyword">deriving</span> <span class="paren1">(<span class="code"><span class="variable">Show,</span> <span class="variable">Read,</span> <span class="variable">Eq,</span> <span class="variable">Ord</span></span>)</span></span></code></pre>

<p>上記Haskellコードのような再帰的な型構造をCommon Lispで表すことは不可能である。
たとえば以下のような直訳が考えられるかと思う。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">deftype</span></i> .list<span class="paren2">(<span class="code">a</span>)</span>
  `<span class="paren2">(<span class="code">or null <span class="paren3">(<span class="code">cons ,a <span class="paren4">(<span class="code">.list ,a</span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<p>実際これで動く処理系もある。（ECL、CLISP）
だが、動かない処理系もある。（CCL、SBCL）</p>

<p>CLHSには以下のようにある。</p>

<blockquote>
<p>Recursive expansion of the type specifier returned as the expansion must terminate, including the expansion of type specifiers which are nested within the expansion.</p>
</blockquote>

<p>再帰的な型構造を表せるのは本当に羨ましい。</p>

<h3>Tree</h3>

<p>前節と同じ理由で本節も再現不可能なので省略。</p>

<h2>7.8</h2>

<p>Haskellに於ける型クラスという機能の、筆者個人の解釈を述べる。
正しいかどうかは知らない。</p>

<p>まず、スタート地点として１章で取り上げた等値関数の問題を考える。
すなわち、等値性はアプリケーションによるので、それ用の関数を定義すべきだ、という考えである。
これは正論であるが、デメリットを伴う。
プログラマが行いたいのは、オブジェクトが同じか否かの比較であるだけなのに、<code>A-EQUAL</code>, <code>B-EQUAL</code>,,, <code>N-EQUAL</code>と大量の名前を必要とする。
なんにせよやりたいことは等値比較なので、同じ名前で行いたい。</p>

<p>この問題に対する一つの回答がオブジェクト指向によりもたらされた。
あらゆるデータはオブジェクトであり、 振る舞いはオブジェクトが知っている。
アプリケーションによる特殊な等値比較関数が必要なら、メソッドとしてオブジェクトに持たせればいい。
既存のものが使えるなら、継承すればいい。
これにより、関数の名前は、例えば、<code>==</code>一つあればいい。</p>

<p>ただしこれにもデメリットがつきまとう。
メソッドのディスパッチは実行時に行われるので、それがオーバーヘッドとなる。
その問題に対する一つの回答こそ、型クラスの一側面であると筆者は考える。</p>

<p>型というものは、コンパイラに対するヒントである。
型情報が充分コンパイラに与えられていれば、メソッドのディスパッチをコンパイル時に行える。
なお、デメリットは型の情報が正しく指定されていなければならないという点だ。
スタート地点では名前に型情報がプリフィックスとして付いていると考えれば、ぐるっと一周して戻ってきた感はある。
しかしながら型推論を充分行えるコンパイラであれば、型情報の記述は減らせるので、トータルで見れば記述量は減らせる事が出来るのかもしれない。</p>

<p>Common Lispにそのような機能は存在しない。
近いことを行うライブラリとしてはinlined-generic-functionがある。
Inlined-generic-functionは優秀なプロダクトであるが、その欠点はそれが総称関数である点だ。
すなわち、メソッドはクラスの単位でしか作られない。</p>

<p>Common Lispはオブジェクト指向もサポートしている言語である。
CLOSと呼ばれるそれは、もともとあったLispの上にLispを使って作られたものだ。
それ自体はCommon Lispという言語の強力さを表しているが、それ故にCommon Lispには負債が伴ってもいる。
もともとあった型システムと、CLOSのクラスシステムとの互換性が完全でないのだ。</p>

<p>１というデータがある。
これの型は何だろうか。
Common Lispに於いて、１は<code>BIT</code>という型になる。
そして<code>BIT</code>はクラスではない。
よって<code>BIT</code>にスペシャライズドされたメソッドは作れない。
同様に<code>(unsigned-byte 8)</code>にスペシャライズドされたメソッドも作れないし、<code>(cons fixnum fixnum)</code>にスペシャライズドされたメソッドも作れない。</p>

<p>これまで見てきたように、本章で作ってきた<code>DEFDATA</code>というマクロは、古式ゆかしき型システムに依存しているものである。
よって、inlined-generic-functionとは別に自前で作らねばならない。</p>

<h3>draft</h3>

<p>ではコードを書き始める前に、想定される仕様の策定を行おう。</p>

<h4>(define-type-class(name &amp;rest vars)super-classes methods &amp;rest rest)</h4>

<p>CLOSに於ける<code>DEFCLASS</code>と<code>DEFGENERIC</code>とを統合したものに相当するマクロとして<code>DEFINE-TYPE-CLASS</code>を考える。
<code>DEFINE-TYPE-CLASS</code>は、インターフェイスとなる関数とそのコンパイラマクロに展開されるマクロだ。
また、interfaceにテーブルを紐付ける役割も行う。</p>

<p>コンパイラマクロは、コンパイル時にまず型制約のチェックを行う。
（それは<code>CHECK-SIGNATURE</code>で行われる。）
破綻していればエラーとする。
さもなくばインスタンスを探す。
（それは<code>GET-INSTANCE-LAMBDA</code>で行われる。）
見つからなければ<code>WARNING</code>を発する。
さもなくばインターフェイスを見つかったラムダフォームで置き換える。</p>

<p>インターフェイス関数は、実行時に受け取った引数の型をキーにして、インスタンステーブルからラムダフォームを探してくる。
（これは<code>GET-INSTANCE-LAMBDA</code>で行われる。）
見つからなければエラーを発する。
さもなくば見つかったインスタンスに実引数を適用させる。</p>

<h4>(definstance interface instance-lambda-list &amp;body body)</h4>

<p>CLOSに於ける<code>DEFMETHOD</code>に相当するマクロとして<code>DEFINSTANCE</code>を考える。
<code>DEFINSTANCE</code>は、インターフェイス関数にインスタンスラムダを紐付けるマクロだ。
（それは<code>ADD-INSTANCE</code>で行われる。） </p>

<h4>(get-instance-lambda interface type*)</h4>

<p>型のリストをキーにinterface（シンボル）からラムダフォームを探す。
まず、適応可能な全てのインスタンスを集める。
（それは<code>COLLECT-INSTANCE</code>で行われる。）
しかる後に最も特定的なインスタンスを選択する。
（それは<code>COMPUTE-APPLICABLE-INSTANCE</code>で行われる。）
interfaceからテーブルを取り出すためには<code>INSTANCE-TABLE</code>を使う。
テーブルは、キーに型のリスト、値にラムダフォームが入っているものとする。
見つからなければ<code>NIL</code>を返す。</p>

<h4>(collect-instance type* interface)</h4>

<p>型のリストをキーに、interfaceに登録されている適用可能なインスタンスを全て集める。</p>

<h4>(compute-applicable-instance list)</h4>

<p>最も特定的なインスタンスを返す。</p>

<h4>(add-instance interface type* lambda-form)</h4>

<p>インターフェイスに紐付けられたテーブルに型リストをキーにしてラムダフォームを登録する。</p>

<h4>(instance-table interface)</h4>

<p>インターフェイスに紐付けられたインスタンステーブルを返す。</p>

<h4>(check-signature signature type*)</h4>

<p>type*がsignatureを満たすかチェックする。
満たさなくばエラーを発する。</p>

<h3>implementation</h3>

<p>では実装に移ろう。</p>

<p>コンパイル時に何らかのデータを取り扱いたい場合、そのデータはシンボルに紐づけておくのがセオリーだ。
まずは、それらのデータ型から作る。</p>

<p>定義される型クラス名となるシンボルに紐付けられるデータ構造。</p>

<pre><code><span class="code"><span class="comment">;;;; TYPE-CLASS OBJECT
</span><span class="paren1">(<span class="code"><i><span class="symbol">defstruct</span></i><span class="paren2">(<span class="code">type-class<span class="paren3">(<span class="code"><span class="keyword">:constructor</span> make-info</span>)</span><span class="paren3">(<span class="code"><span class="keyword">:copier</span> nil</span>)</span>
                     <span class="paren3">(<span class="code"><span class="keyword">:predicate</span> nil</span>)</span><span class="paren3">(<span class="code"><span class="keyword">:conc-name</span> type-</span>)</span></span>)</span>
  <span class="paren2">(<span class="code">name <span class="paren3">(<span class="code">error <span class="string">"Name is required."</span></span>)</span> <span class="keyword">:type</span> symbol <span class="keyword">:read-only</span> t</span>)</span>
  <span class="paren2">(<span class="code">direct-superclasses nil <span class="keyword">:type</span> list</span>)</span>
  <span class="paren2">(<span class="code">direct-subclasses nil <span class="keyword">:type</span> list</span>)</span></span>)</span></span></code></pre>

<p>CLOSで言うところの総称関数、その名前シンボルに紐付けられるデータ構造。</p>

<pre><code><span class="code"><span class="comment">;;;; INSTANCE OBJECT
</span><span class="paren1">(<span class="code"><i><span class="symbol">defstruct</span></i><span class="paren2">(<span class="code">type-class-instance<span class="paren3">(<span class="code"><span class="keyword">:constructor</span> instance-info</span>)</span><span class="paren3">(<span class="code"><span class="keyword">:copier</span> nil</span>)</span>
                              <span class="paren3">(<span class="code"><span class="keyword">:predicate</span> nil</span>)</span></span>)</span>
  <span class="paren2">(<span class="code">lambda-list nil <span class="keyword">:type</span> list <span class="keyword">:read-only</span> t</span>)</span>
  <span class="paren2">(<span class="code">return-type nil <span class="keyword">:type</span> <span class="paren3">(<span class="code">or list symbol</span>)</span><span class="keyword">:read-only</span> t</span>)</span>
  <span class="paren2">(<span class="code">type-class <span class="paren3">(<span class="code">error <span class="string">"required"</span></span>)</span> <span class="keyword">:type</span> symbol <span class="keyword">:read-only</span> t</span>)</span>
  <span class="paren2">(<span class="code">table nil <span class="keyword">:type</span> list</span>)</span>
  <span class="paren2">(<span class="code"><i><span class="symbol">default</span></i> nil <span class="keyword">:type</span> list <span class="keyword">:read-only</span> t</span>)</span></span>)</span></span></code></pre>

<p>CLOSで言うところの総称関数、その名前シンボルの事を上記仕様では<code>INTERFACE</code>と呼んでいた。
ラッパがあった方が便利だ。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> instance-type-class<span class="paren2">(<span class="code">interface</span>)</span>
  <span class="paren2">(<span class="code">type-class-instance-type-class<span class="paren3">(<span class="code">get interface 'instance</span>)</span></span>)</span></span>)</span>

<span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> instance-default<span class="paren2">(<span class="code">interface</span>)</span>
  <span class="paren2">(<span class="code">type-class-instance-default<span class="paren3">(<span class="code">get interface 'instance</span>)</span></span>)</span></span>)</span>

<span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> instance-lambda-list<span class="paren2">(<span class="code">interface</span>)</span>
  <span class="paren2">(<span class="code">type-class-instance-lambda-list<span class="paren3">(<span class="code">get interface 'instance</span>)</span></span>)</span></span>)</span>

<span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> instance-return-type<span class="paren2">(<span class="code">interface</span>)</span>
  <span class="paren2">(<span class="code">type-class-instance-return-type<span class="paren3">(<span class="code">get interface 'instance</span>)</span></span>)</span></span>)</span>

<span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> instance-p<span class="paren2">(<span class="code">interface</span>)</span>
  <span class="paren2">(<span class="code">get interface 'instance</span>)</span></span>)</span></span></code></pre>

<p><code>INSTANCE-TABLE</code>に関してはSETF関数も定義しておく。</p>

<pre><code><span class="code"><span class="comment">;;;; INSTANCE-TABLE
</span><span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> instance-table<span class="paren2">(<span class="code">interface</span>)</span>
  <span class="paren2">(<span class="code">type-class-instance-table<span class="paren3">(<span class="code">get interface 'instance</span>)</span></span>)</span></span>)</span>
<span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> <span class="paren2">(<span class="code">setf instance-table</span>)</span><span class="paren2">(<span class="code">new interface</span>)</span>
  <span class="paren2">(<span class="code">setf<span class="paren3">(<span class="code">type-class-instance-table<span class="paren4">(<span class="code">get interface 'instance</span>)</span></span>)</span>new</span>)</span></span>)</span></span></code></pre>

<p>筆者は、丁寧にリファクタリングされたマクロはBNFに近くなるという印象を持っている。
マクロ<code>DEFINE-TYPE-CLASS</code>は大変多くの仕事を請け負うものではあるが、それでも読みにくくはないはずだ。</p>

<pre><code><span class="code"><span class="comment">;;;; DEFINE-TYPE-CLASS
</span><span class="paren1">(<span class="code"><i><span class="symbol">defmacro</span></i> <i><span class="symbol">define-type-class</span></i><span class="paren2">(<span class="code"><span class="paren3">(<span class="code">name &amp;rest vars</span>)</span>super-classes methods &amp;rest rest</span>)</span>
  <span class="comment">;; trivial syntax checking.
</span>  <span class="paren2">(<span class="code">assert<span class="paren3">(<span class="code">every #'symbolp vars</span>)</span></span>)</span>
  <span class="comment">;; as canonicalize
</span>  <span class="paren2">(<span class="code">map-into vars #'envar vars</span>)</span>
  <span class="comment">;; body
</span>  `<span class="paren2">(<span class="code"><i><span class="symbol">EVAL-WHEN</span></i><span class="paren3">(<span class="code"><span class="keyword">:COMPILE-TOPLEVEL</span> <span class="keyword">:LOAD-TOPLEVEL</span> <span class="keyword">:EXECUTE</span></span>)</span>
     <span class="paren3">(<span class="code">SETF<span class="paren4">(<span class="code">GET ',name 'TYPE-CLASS</span>)</span><span class="paren4">(<span class="code">MAKE-INFO <span class="keyword">:NAME</span> ',name</span>)</span></span>)</span>
     ,@<span class="paren3">(<span class="code">when super-classes
         <span class="paren4">(<span class="code">&lt;type-class-relation-setter&gt; name super-classes</span>)</span></span>)</span>
     ,@<span class="paren3">(<span class="code"><i><span class="symbol">loop</span></i>
         <span class="keyword">:for</span> <span class="paren4">(<span class="code">method lambda-list return-type</span>)</span> <span class="keyword">:in</span> methods
         <span class="keyword">:for</span> gensyms = <span class="paren4">(<span class="code">gensyms lambda-list</span>)</span>
         <span class="keyword">:do</span> <span class="paren4">(<span class="code">setf <span class="comment">; as canonicalise
</span>               lambda-list <span class="paren5">(<span class="code">patternize lambda-list</span>)</span>
               return-type <span class="paren5">(<span class="code">patternize return-type</span>)</span></span>)</span>
         <span class="keyword">:collect</span> <span class="paren4">(<span class="code">&lt;instance-info-setter&gt; method name lambda-list return-type rest</span>)</span>
         <span class="keyword">:collect</span> <span class="paren4">(<span class="code">&lt;instance-compiler-macro&gt; method gensyms lambda-list return-type</span>)</span>
         <span class="keyword">:collect</span> <span class="paren4">(<span class="code">&lt;instance-interpreter&gt; method gensyms lambda-list</span>)</span></span>)</span>
     ',name</span>)</span></span>)</span>

<span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> envar<span class="paren2">(<span class="code">thing</span>)</span>
  <span class="paren2">(<span class="code">intern<span class="paren3">(<span class="code">format nil <span class="string">"?~A"</span>thing</span>)</span></span>)</span></span>)</span>

<span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> patternize<span class="paren2">(<span class="code">thing</span>)</span>
  <span class="paren2">(<span class="code"><i><span class="symbol">if</span></i><span class="paren3">(<span class="code">millet:type-specifier-p thing</span>)</span>
    thing
    <span class="paren3">(<span class="code"><i><span class="symbol">if</span></i><span class="paren4">(<span class="code">listp thing</span>)</span>
      <span class="paren4">(<span class="code">trestrul:mapleaf #'patternize thing</span>)</span>
      <span class="paren4">(<span class="code">envar thing</span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<p>スーパークラスが指定されているようならその親子関係を各データ構造に登録する、そのためのフォームを生成する。</p>

<pre><code><span class="code"><span class="comment">;;; &lt;type-class-relation-setter&gt;
</span><span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> &lt;type-class-relation-setter&gt;<span class="paren2">(<span class="code">name super-classes</span>)</span>
  `<span class="paren2">(<span class="code"><span class="paren3">(<span class="code">SETF <span class="paren4">(<span class="code">TYPE-DIRECT-SUPERCLASSES<span class="paren5">(<span class="code">GET ',name 'TYPE-CLASS</span>)</span></span>)</span>',super-classes</span>)</span>
    ,@<span class="paren3">(<span class="code"><i><span class="symbol">loop</span></i> <span class="keyword">:for</span> type-class <span class="keyword">:in</span> super-classes
            <span class="keyword">:collect</span>
            `<span class="paren4">(<span class="code">PUSH ',name <span class="paren5">(<span class="code">TYPE-DIRECT-SUBCLASSES<span class="paren6">(<span class="code">GET ',type-class 'TYPE-CLASS</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<p>型クラスは各々メソッドを持っている。
それらメソッドの名前シンボルにメタ情報を登録するフォームを生成する。</p>

<pre><code><span class="code"><span class="comment">;;; &lt;instance-info-setter&gt;
</span><span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> &lt;instance-info-setter<span class="paren2">(<span class="code">method name lambda-list return-type rest</span>)</span>
  `<span class="paren2">(<span class="code">SETF <span class="paren3">(<span class="code">GET ',method 'INSTANCE</span>)</span>
         <span class="paren3">(<span class="code">INSTANCE-INFO <span class="keyword">:TYPE-CLASS</span> ',name
                        <span class="keyword">:LAMBDA-LIST</span> ',lambda-list
                        <span class="keyword">:RETURN-TYPE</span> ',return-type
                        ,@<span class="paren4">(<span class="code"><i><span class="symbol">let</span></i><span class="paren5">(<span class="code"><span class="paren6">(<span class="code"><i><span class="symbol">default</span></i><span class="paren1">(<span class="code">find method rest <span class="keyword">:key</span> #'cadr</span>)</span></span>)</span></span>)</span>
                            <span class="paren5">(<span class="code">when <i><span class="symbol">default</span></i>
                              `<span class="paren6">(<span class="code"><span class="keyword">:DEFAULT</span> '<span class="paren1">(<span class="code"><i><span class="symbol">LAMBDA</span></i>,@<span class="paren2">(<span class="code">cddr <i><span class="symbol">default</span></i></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<p>型クラスに所属している各メソッドに対し働くコンパイラマクロを定義するフォームを生成する。</p>

<pre><code><span class="code"><span class="comment">;;; &lt;instance-compiler-macro&gt;
</span><span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> &lt;instance-compiler-macro&gt;<span class="paren2">(<span class="code">method gensyms lambda-list return-type</span>)</span>
  `<span class="paren2">(<span class="code"><i><span class="symbol">DEFINE-COMPILER-MACRO</span></i>,method<span class="paren3">(<span class="code">&amp;WHOLE WHOLE ,@gensyms &amp;ENVIRONMENT ENV</span>)</span>
     <span class="paren3">(<span class="code">SETF <span class="comment">; as canonicalise. In order to retrieve return type.
</span>       ,@<span class="paren4">(<span class="code"><i><span class="symbol">loop</span></i> <span class="keyword">:for</span> gensym <span class="keyword">:in</span> gensyms
               <span class="keyword">:append</span> `<span class="paren5">(<span class="code">,gensym <span class="paren6">(<span class="code">EXPANDER:EXPAND ,gensym</span>)</span></span>)</span></span>)</span></span>)</span>
     <span class="paren3">(<span class="code"><i><span class="symbol">LET</span></i><span class="paren4">(<span class="code"><span class="paren5">(<span class="code">INFOS<span class="paren6">(<span class="code">COMPUTE-RETURN-TYPES <span class="paren1">(<span class="code">list ,@gensyms</span>)</span> ENV</span>)</span></span>)</span></span>)</span>
       ,@<span class="paren4">(<span class="code">when<span class="paren5">(<span class="code">cdr lambda-list</span>)</span>
           `<span class="paren5">(<span class="code"><span class="paren6">(<span class="code">CHECK-SIGNATURE ',lambda-list INFOS</span>)</span></span>)</span></span>)</span>
       <span class="paren4">(<span class="code"><i><span class="symbol">LET</span></i><span class="paren5">(<span class="code"><span class="paren6">(<span class="code">IL<span class="paren1">(<span class="code">GET-INSTANCE-LAMBDA ',method INFOS</span>)</span></span>)</span></span>)</span>
         <span class="paren5">(<span class="code"><i><span class="symbol">IF</span></i> IL
             ,<span class="paren6">(<span class="code"><i><span class="symbol">if</span></i><span class="paren1">(<span class="code">millet:type-specifier-p return-type</span>)</span>
                `<span class="paren1">(<span class="code">LIST '<i><span class="symbol">THE</span></i> ',return-type <span class="paren2">(<span class="code">LIST IL ,@gensyms</span>)</span></span>)</span>
                `<span class="paren1">(<span class="code"><i><span class="symbol">LET</span></i><span class="paren2">(<span class="code"><span class="paren3">(<span class="code">RETURN<span class="paren4">(<span class="code">SUBSTITUTE-PATTERN ',return-type <span class="paren5">(<span class="code">UNIFY:UNIFY ',lambda-list <span class="paren6">(<span class="code">SUBST '_ '* INFOS</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>
                   <span class="paren2">(<span class="code"><i><span class="symbol">IF</span></i> RETURN
                       <span class="paren3">(<span class="code">LIST '<i><span class="symbol">THE</span></i> RETURN <span class="paren4">(<span class="code">LIST IL ,@gensyms</span>)</span></span>)</span>
                       <span class="paren3">(<span class="code">LIST IL ,@gensyms</span>)</span></span>)</span></span>)</span></span>)</span>
             <span class="paren6">(<span class="code"><i><span class="symbol">PROGN</span></i> <span class="paren1">(<span class="code">WHEN <span class="special">*COMPILE-FILE-PATHNAME*</span>
                      <span class="paren2">(<span class="code">WARN <span class="string">"Can not get instance of ~S"</span> WHOLE</span>)</span></span>)</span>
                    <span class="comment">;; In order to avoid expanding macros twice,
</span>                    <span class="comment">;; we should use canonicalized `GENSYMS`.
</span>                    <span class="comment">;; And in order to trick `compiler-macroexpand-1` returns nil
</span>                    <span class="comment">;; as second value, we must destructively modify `WHOLE`.
</span>                    <span class="comment">;; Or `compiler-macroexpand` get into infinite expanding.
</span>                    <span class="paren1">(<span class="code">RPLACD WHOLE <span class="paren2">(<span class="code">LIST ,@gensyms</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<p>ここでは仕様になかったヘルパー（しかもそれなりに規模の大きなもの）が大量に必要になる。
見通しが甘かったとも言えるが、あまりにがんじがらめの仕様にしてしまうと実装においての工夫のしどころがなくなってしまう。
（特に最適化まわりに関して。）
この辺はさじ加減が難しいところ。</p>

<p>また、これらのヘルパーを実装するにあたり必要な情報をコンパイル時に得られるようにするため、<code>DEFDATA</code>マクロにも手を入れなければならない。
具体的には、ADTがリテラルで書かれていた場合、その値から対応する型を特定できねばならない。</p>

<p>ADTに関するメタインフォを格納するデータ構造。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">defstruct</span></i><span class="paren2">(<span class="code">adt <span class="paren3">(<span class="code"><span class="keyword">:copier</span> nil</span>)</span><span class="paren3">(<span class="code"><span class="keyword">:predicate</span> nil</span>)</span></span>)</span>
  <span class="paren2">(<span class="code">type-of <span class="paren3">(<span class="code">error <span class="string">"required"</span></span>)</span> <span class="keyword">:read-only</span> t <span class="keyword">:type</span> <span class="paren3">(<span class="code">or symbol list</span>)</span></span>)</span>
  <span class="paren2">(<span class="code">types <span class="paren3">(<span class="code">error <span class="string">"required"</span></span>)</span> <span class="keyword">:read-only</span> t <span class="keyword">:type</span> <span class="paren3">(<span class="code">or symbol list</span>)</span></span>)</span>
  <span class="paren2">(<span class="code">order <span class="paren3">(<span class="code">error <span class="string">"required"</span></span>)</span> <span class="keyword">:type</span> fixnum <span class="keyword">:read-only</span> t</span>)</span></span>)</span></span></code></pre>

<p>各種trivialなヘルパー。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> adv-p<span class="paren2">(<span class="code">thing</span>)</span>
  <span class="paren2">(<span class="code">or <span class="paren3">(<span class="code">when<span class="paren4">(<span class="code">keywordp thing</span>)</span>
        <span class="paren4">(<span class="code">get thing 'adt-meta-info</span>)</span></span>)</span>
      <span class="paren3">(<span class="code">when<span class="paren4">(<span class="code">and <span class="paren5">(<span class="code">listp thing</span>)</span>
                <span class="paren5">(<span class="code">symbolp <span class="paren6">(<span class="code">car thing</span>)</span></span>)</span></span>)</span>
        <span class="paren4">(<span class="code">get <span class="paren5">(<span class="code">car thing</span>)</span> 'adt-meta-info</span>)</span></span>)</span></span>)</span></span>)</span>

<span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> data-type-of<span class="paren2">(<span class="code">thing</span>)</span>
  <span class="paren2">(<span class="code"><i><span class="symbol">let</span></i><span class="paren3">(<span class="code"><span class="paren4">(<span class="code">adt<span class="paren5">(<span class="code">adv-p thing</span>)</span></span>)</span></span>)</span>
    <span class="paren3">(<span class="code"><i><span class="symbol">if</span></i> adt
      <span class="paren4">(<span class="code"><i><span class="symbol">let</span></i><span class="paren5">(<span class="code"><span class="paren6">(<span class="code">types<span class="paren1">(<span class="code">adt-types adt</span>)</span></span>)</span></span>)</span>
        <span class="paren5">(<span class="code"><i><span class="symbol">if</span></i><span class="paren6">(<span class="code">null types</span>)</span>
          <span class="paren6">(<span class="code">adt-type-of adt</span>)</span>
          <span class="paren6">(<span class="code"><i><span class="symbol">if</span></i><span class="paren1">(<span class="code">eq 'eql <span class="paren2">(<span class="code">car types</span>)</span></span>)</span>
            <span class="paren1">(<span class="code">adt-type-of adt</span>)</span>
            <span class="paren1">(<span class="code">list* <span class="paren2">(<span class="code">car <span class="paren3">(<span class="code">adt-type-of adt</span>)</span></span>)</span>
                   <span class="paren2">(<span class="code">mapcar <span class="paren3">(<span class="code"><i><span class="symbol">lambda</span></i><span class="paren4">(<span class="code">type value</span>)</span>
                             <span class="paren4">(<span class="code"><i><span class="symbol">if</span></i><span class="paren5">(<span class="code">unify:variablep type</span>)</span>
                               <span class="paren5">(<span class="code">data-type-of value</span>)</span>
                               type</span>)</span></span>)</span>
                           <span class="paren3">(<span class="code">adt-types adt</span>)</span>
                           <span class="paren3">(<span class="code">cdr thing</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>
      <span class="paren4">(<span class="code"><i><span class="symbol">if</span></i><span class="paren5">(<span class="code">not<span class="paren6">(<span class="code">functionp thing</span>)</span></span>)</span>
        <span class="paren5">(<span class="code">class-name<span class="paren6">(<span class="code">class-of thing</span>)</span></span>)</span>
        <span class="paren5">(<span class="code"><i><span class="symbol">let</span></i><span class="paren6">(<span class="code"><span class="paren1">(<span class="code">name<span class="paren2">(<span class="code">millet:function-name thing</span>)</span></span>)</span></span>)</span>
          <span class="paren6">(<span class="code"><i><span class="symbol">if</span></i> name
            <span class="paren1">(<span class="code">introspect-environment:function-type name</span>)</span>
            '<i><span class="symbol">function</span></i></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>

<span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> data-order<span class="paren2">(<span class="code">thing</span>)</span>
  <span class="paren2">(<span class="code"><i><span class="symbol">let</span></i><span class="paren3">(<span class="code"><span class="paren4">(<span class="code">adt<span class="paren5">(<span class="code">adv-p thing</span>)</span></span>)</span></span>)</span>
    <span class="paren3">(<span class="code">when adt
      <span class="paren4">(<span class="code">adt-order adt</span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<p>DEFDATAに関する変更は<code>&lt;meta-info-setter&gt;</code>のみで良い。
コンストラクタシンボルにメタインフォを登録する、そのためのフォームを生成する。</p>

<pre><code><span class="code"><span class="comment">;;; &lt;meta-info-setter&gt;
</span><span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> &lt;meta-info-setter&gt;<span class="paren2">(<span class="code">constructor order lambda-list name</span>)</span>
  <span class="paren2">(<span class="code"><i><span class="symbol">let</span></i><span class="paren3">(<span class="code"><span class="paren4">(<span class="code">c <span class="paren5">(<span class="code">alexandria:ensure-car constructor</span>)</span></span>)</span></span>)</span>
    `<span class="paren3">(<span class="code">SETF <span class="paren4">(<span class="code">GET ',c 'adt-meta-info</span>)</span>
           <span class="paren4">(<span class="code">MAKE-ADT <span class="keyword">:TYPE-OF</span> ',<span class="paren5">(<span class="code"><i><span class="symbol">if</span></i> lambda-list
                                  <span class="paren6">(<span class="code">constructor-return-type name</span>)</span>
                                  name</span>)</span>
                     <span class="keyword">:TYPES</span> ',<span class="paren5">(<span class="code">arg-types constructor lambda-list</span>)</span>
                     <span class="keyword">:ORDER</span> ,order</span>)</span></span>)</span></span>)</span></span>)</span>

<span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> arg-types<span class="paren2">(<span class="code">constructor args</span>)</span>
  <span class="paren2">(<span class="code"><i><span class="symbol">cond</span></i>
    <span class="paren3">(<span class="code"><span class="paren4">(<span class="code">keywordp constructor</span>)</span> `<span class="paren4">(<span class="code">eql ,constructor</span>)</span></span>)</span>
    <span class="paren3">(<span class="code"><span class="paren4">(<span class="code">or args <span class="paren5">(<span class="code">list-constructor-p constructor</span>)</span></span>)</span>
     <span class="paren4">(<span class="code">sublis <span class="paren5">(<span class="code">mapcar <span class="paren6">(<span class="code"><i><span class="symbol">lambda</span></i><span class="paren1">(<span class="code">elt</span>)</span>
                       <span class="paren1">(<span class="code">cons elt <span class="paren2">(<span class="code">Envar elt</span>)</span></span>)</span></span>)</span>
                     args</span>)</span>
             <span class="paren5">(<span class="code">cdr constructor</span>)</span></span>)</span></span>)</span>
    <span class="paren3">(<span class="code">t <span class="paren4">(<span class="code">mapcar <span class="paren5">(<span class="code"><i><span class="symbol">lambda</span></i><span class="paren6">(<span class="code">slot</span>)</span>
                 <span class="paren6">(<span class="code"><i><span class="symbol">if</span></i><span class="paren1">(<span class="code">symbolp slot</span>)</span>
                   t
                   <span class="paren1">(<span class="code">getf slot <span class="keyword">:type</span> t</span>)</span></span>)</span></span>)</span>
               <span class="paren5">(<span class="code">cdr constructor</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<p>定数フォームから取り出した値をラップしておくための構造体。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">defstruct</span></i><span class="paren2">(<span class="code">constant <span class="paren3">(<span class="code"><span class="keyword">:constructor</span> wrap-value<span class="paren4">(<span class="code">value</span>)</span></span>)</span><span class="paren3">(<span class="code"><span class="keyword">:copier</span> nil</span>)</span></span>)</span>
  <span class="paren2">(<span class="code">value nil <span class="keyword">:read-only</span> t</span>)</span></span>)</span></span></code></pre>

<p>内部エラー用コンディション。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">define-condition</span></i> internal-logical-error<span class="paren2">(<span class="code">cell-error</span>)</span>
  <span class="paren2">(<span class="code"><span class="paren3">(<span class="code">datum <span class="keyword">:initarg</span> <span class="keyword">:datum</span> <span class="keyword">:accessor</span> error-datum</span>)</span></span>)</span>
  <span class="paren2">(<span class="code"><span class="keyword">:report</span><span class="paren3">(<span class="code"><i><span class="symbol">lambda</span></i><span class="paren4">(<span class="code">c <span class="special">*standard-output*</span></span>)</span>
            <span class="paren4">(<span class="code">format t <span class="string">"INTERNAL LOGICAL ERROR: ~S~%~S trapped with ~S."</span>
                    <span class="paren5">(<span class="code">type-of c</span>)</span>
                    <span class="paren5">(<span class="code">cell-error-name c</span>)</span>
                    <span class="paren5">(<span class="code">error-datum c</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>
<span class="paren1">(<span class="code"><i><span class="symbol">define-condition</span></i> exhausts-clauses<span class="paren2">(<span class="code">internal-logical-error</span>)</span><span class="paren2">(<span class="code"></span>)</span></span>)</span>
<span class="paren1">(<span class="code"><i><span class="symbol">define-condition</span></i> unexpected-macro<span class="paren2">(<span class="code">internal-logical-error</span>)</span><span class="paren2">(<span class="code"></span>)</span></span>)</span>
<span class="paren1">(<span class="code"><i><span class="symbol">define-condition</span></i> unexpected-quote<span class="paren2">(<span class="code">internal-logical-error</span>)</span><span class="paren2">(<span class="code"></span>)</span></span>)</span>
<span class="paren1">(<span class="code"><i><span class="symbol">define-condition</span></i> unexpected-local-macro<span class="paren2">(<span class="code">internal-logical-error</span>)</span><span class="paren2">(<span class="code"></span>)</span></span>)</span></span></code></pre>

<p>フォームの返り値を求める。
コンパイラマクロフォームの可読性を高めるため、利便性の高いAPIを提供する役割を担う。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> compute-return-types<span class="paren2">(<span class="code">var* &amp;optional env</span>)</span>
  <span class="paren2">(<span class="code"><i><span class="symbol">loop</span></i> <span class="keyword">:for</span> var <span class="keyword">:in</span> var*
        <span class="keyword">:collect</span> <span class="paren3">(<span class="code">compute-return-type var env</span>)</span></span>)</span></span>)</span>
</span></code></pre>

<p>実際の各処理、特に条件分岐を担当する。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> compute-return-type<span class="paren2">(<span class="code">var &amp;optional env</span>)</span>
  <span class="paren2">(<span class="code"><i><span class="symbol">cond</span></i>
    <span class="paren3">(<span class="code"><span class="paren4">(<span class="code">constantp var</span>)</span> <span class="comment">; lisp object.
</span>     <span class="paren4">(<span class="code"><i><span class="symbol">let</span></i><span class="paren5">(<span class="code"><span class="paren6">(<span class="code">value<span class="paren1">(<span class="code">introspect-environment:constant-form-value var env</span>)</span></span>)</span></span>)</span>
       <span class="paren5">(<span class="code"><i><span class="symbol">if</span></i><span class="paren6">(<span class="code">adv-p value</span>)</span> <span class="comment">; literal adt.
</span>         <span class="paren6">(<span class="code">data-type-of value</span>)</span>
         <span class="paren6">(<span class="code">wrap-value value</span>)</span></span>)</span></span>)</span></span>)</span>
    <span class="paren3">(<span class="code"><span class="paren4">(<span class="code">symbolp var</span>)</span> <span class="comment">; free variable.
</span>     <span class="paren4">(<span class="code">or <span class="paren5">(<span class="code">introspect-environment:variable-type var env</span>)</span>
         T</span>)</span></span>)</span>
    <span class="paren3">(<span class="code"><span class="paren4">(<span class="code">and <span class="paren5">(<span class="code">listp var</span>)</span> <span class="comment">; instance call.
</span>          <span class="paren5">(<span class="code">instance-p <span class="paren6">(<span class="code">car var</span>)</span></span>)</span></span>)</span>
     <span class="paren4">(<span class="code">compute-instance-call-return-type var</span>)</span></span>)</span>
    <span class="paren3">(<span class="code"><span class="paren4">(<span class="code">and <span class="paren5">(<span class="code">listp var</span>)</span>
          <span class="paren5">(<span class="code">symbolp <span class="paren6">(<span class="code">car var</span>)</span></span>)</span></span>)</span>
     <span class="paren4">(<span class="code">compute-standard-form-return-type var env</span>)</span></span>)</span>
    <span class="paren3">(<span class="code">t <span class="paren4">(<span class="code">error 'exhausts-clauses <span class="keyword">:name</span> 'compute-return-type <span class="keyword">:datum</span> var</span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<p>インスタンスコールフォームから返り値を求める。
ここでユニフィケーションを行えるようにするために、<code>DEFINE-TYPE-CLASS</code>マクロでは変数を事前に論理変数化してある。
<code>COMPUTE-RETURN-TYPE</code>の可読性を上げるため、利便性の高いAPIを提供する役目を担う。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> compute-instance-call-return-type<span class="paren2">(<span class="code">call-form</span>)</span>
  <span class="paren2">(<span class="code"><i><span class="symbol">let</span></i><span class="paren3">(<span class="code"><span class="paren4">(<span class="code">pattern<span class="paren5">(<span class="code">instance-return-type<span class="paren6">(<span class="code">car call-form</span>)</span></span>)</span></span>)</span>
       <span class="paren4">(<span class="code">environment<span class="paren5">(<span class="code">unify:unify <span class="paren6">(<span class="code">instance-lambda-list<span class="paren1">(<span class="code">car call-form</span>)</span></span>)</span>
                                <span class="paren6">(<span class="code">subst '_ '* <span class="paren1">(<span class="code">compute-return-types<span class="paren2">(<span class="code">cdr call-form</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>
    <span class="paren3">(<span class="code">substitute-pattern pattern environment</span>)</span></span>)</span></span>)</span></span></code></pre>

<p>ユニフィケーションの結果に基づきパターンを置き換える。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> substitute-pattern<span class="paren2">(<span class="code">pattern environment</span>)</span>
  <span class="paren2">(<span class="code">trestrul:asubst-if <span class="paren3">(<span class="code"><i><span class="symbol">lambda</span></i><span class="paren4">(<span class="code">var</span>)</span>
                        <span class="paren4">(<span class="code"><i><span class="symbol">let</span></i><span class="paren5">(<span class="code"><span class="paren6">(<span class="code">return-type <span class="paren1">(<span class="code">unify:find-variable-value var environment</span>)</span></span>)</span></span>)</span>
                          <span class="paren5">(<span class="code"><i><span class="symbol">if</span></i><span class="paren6">(<span class="code">typep return-type '<span class="paren1">(<span class="code">cons <span class="paren2">(<span class="code">eql values</span>)</span>t</span>)</span></span>)</span>
                            <span class="paren6">(<span class="code">cadr return-type</span>)</span>
                            return-type</span>)</span></span>)</span></span>)</span>
                      #'unify:variablep
                      pattern</span>)</span></span>)</span></span></code></pre>

<p>通常のリスプフォームから返り値を求める。
条件分岐を担う。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> compute-standard-form-return-type<span class="paren2">(<span class="code">form env</span>)</span>
  <span class="paren2">(<span class="code">multiple-value-bind<span class="paren3">(<span class="code">type localp declaration</span>)</span><span class="paren3">(<span class="code">introspect-environment:function-information <span class="paren4">(<span class="code">car form</span>)</span>env</span>)</span>
    <span class="paren3">(<span class="code">declare<span class="paren4">(<span class="code">ignore localp</span>)</span></span>)</span>
    <span class="paren3">(<span class="code">case type
      <span class="paren4">(<span class="code"><span class="paren5">(<span class="code">nil</span>)</span> <span class="paren5">(<span class="code">warn <span class="string">"Undefined function ~S. ~S"</span><span class="paren6">(<span class="code">car form</span>)</span>form</span>)</span></span>)</span>
      <span class="paren4">(<span class="code"><span class="keyword">:special-form</span> <span class="paren5">(<span class="code">special-operator-return-type form env</span>)</span></span>)</span>
      <span class="paren4">(<span class="code"><span class="keyword">:macro</span> <span class="paren5">(<span class="code">error 'unexpected-macro <span class="keyword">:name</span> 'compute-standard-form-return-type
                     <span class="keyword">:datum</span> form</span>)</span></span>)</span>
      <span class="paren4">(<span class="code"><span class="keyword">:function</span>
        <span class="paren5">(<span class="code"><i><span class="symbol">let</span></i><span class="paren6">(<span class="code"><span class="paren1">(<span class="code">ftype<span class="paren2">(<span class="code">assoc 'ftype declaration</span>)</span></span>)</span></span>)</span>
          <span class="paren6">(<span class="code"><i><span class="symbol">if</span></i> ftype
            <span class="paren1">(<span class="code">ftype-return-type <span class="paren2">(<span class="code">cdr ftype</span>)</span></span>)</span>
            <span class="paren1">(<span class="code"><i><span class="symbol">progn</span></i> <span class="paren2">(<span class="code">warn <span class="string">"Could not determine type of ~S"</span>form</span>)</span>
                   T</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<p>特殊形式フォームから返り値の型を求める。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> special-operator-return-type<span class="paren2">(<span class="code">form env</span>)</span>
  <span class="paren2">(<span class="code">case <span class="paren3">(<span class="code">car form</span>)</span>
    <span class="paren3">(<span class="code"><span class="paren4">(<span class="code"><i><span class="symbol">progn</span></i> <i><span class="symbol">progv</span></i> <i><span class="symbol">let</span></i> <i><span class="symbol">let*</span></i> <i><span class="symbol">flet</span></i> <i><span class="symbol">labels</span></i> <i><span class="symbol">lambda</span></i> <i><span class="symbol">setq</span></i> <i><span class="symbol">locally</span></i> <i><span class="symbol">eval-when</span></i></span>)</span>
     <span class="paren4">(<span class="code">compute-return-type<span class="paren5">(<span class="code">car<span class="paren6">(<span class="code">last form</span>)</span></span>)</span>env</span>)</span></span>)</span>
    <span class="paren3">(<span class="code"><span class="paren4">(<span class="code"><i><span class="symbol">the</span></i></span>)</span><span class="paren4">(<span class="code">canonicalize-return-type<span class="paren5">(<span class="code">second form</span>)</span></span>)</span></span>)</span>
    <span class="paren3">(<span class="code"><span class="paren4">(<span class="code"><i><span class="symbol">unwind-protect</span></i> <i><span class="symbol">multiple-value-prog1</span></i> <i><span class="symbol">multiple-value-call</span></i> <i><span class="symbol">load-time-value</span></i></span>)</span>
     <span class="paren4">(<span class="code">compute-return-type<span class="paren5">(<span class="code">second form</span>)</span>env</span>)</span></span>)</span>
    <span class="paren3">(<span class="code"><span class="paren4">(<span class="code"><i><span class="symbol">tagbody</span></i></span>)</span>'null</span>)</span>
    <span class="paren3">(<span class="code"><span class="paren4">(<span class="code"><i><span class="symbol">function</span></i></span>)</span>
     <span class="paren4">(<span class="code"><i><span class="symbol">if</span></i><span class="paren5">(<span class="code">listp <span class="paren6">(<span class="code">second form</span>)</span></span>)</span>
       <span class="paren5">(<span class="code">compute-return-type<span class="paren6">(<span class="code">car<span class="paren1">(<span class="code">last<span class="paren2">(<span class="code">second form</span>)</span></span>)</span></span>)</span>env</span>)</span>
       <span class="paren5">(<span class="code">introspect-environment:function-type<span class="paren6">(<span class="code">second form</span>)</span>env</span>)</span></span>)</span></span>)</span>
    <span class="paren3">(<span class="code"><span class="paren4">(<span class="code"><i><span class="symbol">if</span></i></span>)</span>
     `<span class="paren4">(<span class="code">or ,<span class="paren5">(<span class="code">compute-return-type<span class="paren6">(<span class="code">third form</span>)</span>env</span>)</span>
          ,<span class="paren5">(<span class="code">compute-return-type<span class="paren6">(<span class="code">fourth form</span>)</span>env</span>)</span></span>)</span></span>)</span>
    <span class="paren3">(<span class="code"><span class="paren4">(<span class="code"><i><span class="symbol">quote</span></i></span>)</span>
     <span class="paren4">(<span class="code">error 'unexpected-quote <span class="keyword">:datum</span> form <span class="keyword">:name</span> 'special-operator-return-type</span>)</span></span>)</span>
    <span class="paren3">(<span class="code"><span class="paren4">(<span class="code"><i><span class="symbol">macrolet</span></i> <i><span class="symbol">symbol-macrolet</span></i></span>)</span>
     <span class="paren4">(<span class="code">error 'unexpected-local-macro <span class="keyword">:datum</span> form <span class="keyword">:name</span> 'special-operator-return-type</span>)</span></span>)</span>
    <span class="paren3">(<span class="code">otherwise <span class="comment">; give up. (go throw catch return-from block)
</span>      t</span>)</span></span>)</span></span>)</span></span></code></pre>

<p><code>FTYPE</code>フォームから返り値の型を求める。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> ftype-return-type<span class="paren2">(<span class="code">form</span>)</span>
  <span class="paren2">(<span class="code"><i><span class="symbol">if</span></i><span class="paren3">(<span class="code">symbolp form</span>)</span>
    T
    <span class="paren3">(<span class="code">canonicalize-return-type<span class="paren4">(<span class="code">third form</span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<p>リターンタイプフォームを正規化する。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> canonicalize-return-type<span class="paren2">(<span class="code">return-type</span>)</span>
  <span class="paren2">(<span class="code"><i><span class="symbol">flet</span></i><span class="paren3">(<span class="code"><span class="paren4">(<span class="code">ensure-t<span class="paren5">(<span class="code">thing</span>)</span>
          <span class="paren5">(<span class="code"><i><span class="symbol">if</span></i><span class="paren6">(<span class="code">eq '* thing</span>)</span>
            T
            thing</span>)</span></span>)</span></span>)</span>
    <span class="paren3">(<span class="code"><i><span class="symbol">if</span></i><span class="paren4">(<span class="code">symbolp return-type</span>)</span>
      <span class="paren4">(<span class="code">ensure-t return-type</span>)</span>
      <span class="paren4">(<span class="code"><i><span class="symbol">if</span></i><span class="paren5">(<span class="code">eq 'values <span class="paren6">(<span class="code">car return-type</span>)</span></span>)</span>
        <span class="paren5">(<span class="code">ensure-t <span class="paren6">(<span class="code">cadr return-type</span>)</span></span>)</span>
        return-type</span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<p>コンパイルせずにソースがロードされた場合、もしくは実行時にならないと型情報を得られない場合など、実行時に呼び出されるべきインタープリタ関数を定義するフォームを生成する。</p>

<pre><code><span class="code"><span class="comment">;;;; &lt;instance-interpreter&gt;
</span><span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> &lt;instance-interpreter&gt;<span class="paren2">(<span class="code">method gensyms lambda-list</span>)</span>
  `<span class="paren2">(<span class="code"><i><span class="symbol">DEFUN</span></i>,method,gensyms
     ,@<span class="paren3">(<span class="code">when<span class="paren4">(<span class="code">cdr lambda-list</span>)</span>
         `<span class="paren4">(<span class="code"><span class="paren5">(<span class="code">CHECK-SIGNATURE ',lambda-list <span class="paren6">(<span class="code">LIST ,@<span class="paren1">(<span class="code">mapcar <span class="paren2">(<span class="code"><i><span class="symbol">lambda</span></i><span class="paren3">(<span class="code">sym</span>)</span>
                                                            `<span class="paren3">(<span class="code">DATA-TYPE-OF ,sym</span>)</span></span>)</span>
                                                          gensyms</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>
     <span class="paren3">(<span class="code"><i><span class="symbol">LET</span></i><span class="paren4">(<span class="code"><span class="paren5">(<span class="code">INSTANCE<span class="paren6">(<span class="code">OR <span class="paren1">(<span class="code">GET-INSTANCE-LAMBDA ',method <span class="paren2">(<span class="code">LIST ,@<span class="paren3">(<span class="code"><i><span class="symbol">loop</span></i> <span class="keyword">:for</span> s <span class="keyword">:in</span> gensyms
                                                                   <span class="keyword">:collect</span> `<span class="paren4">(<span class="code">DATA-TYPE-OF ,s</span>)</span></span>)</span></span>)</span></span>)</span>
                       <span class="paren1">(<span class="code">INSTANCE-DEFAULT ',method</span>)</span></span>)</span></span>)</span></span>)</span>
       <span class="paren4">(<span class="code"><i><span class="symbol">IF</span></i> INSTANCE
           <span class="paren5">(<span class="code"><i><span class="symbol">LET</span></i><span class="paren6">(<span class="code"><span class="paren1">(<span class="code">DECLARED<span class="paren2">(<span class="code">INSERT-DECLARE INSTANCE <span class="paren3">(<span class="code">LIST ,@gensyms</span>)</span></span>)</span></span>)</span></span>)</span>
             <span class="paren6">(<span class="code">FUNCALL <span class="paren1">(<span class="code">COERCE DECLARED '<i><span class="symbol">FUNCTION</span></i></span>)</span>
                      ,@gensyms</span>)</span></span>)</span>
           <span class="paren5">(<span class="code">ERROR <span class="string">"Instance is not found. ~S ~S"</span>',method <span class="paren6">(<span class="code">LIST ,@gensyms</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<p><code>GET-INSTANCE-LAMBDA</code>が返したラムダフォームに型情報を付与する。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> insert-declare<span class="paren2">(<span class="code">form values</span>)</span>
  <span class="paren2">(<span class="code"><i><span class="symbol">labels</span></i><span class="paren3">(<span class="code"><span class="paren4">(<span class="code">actual-type<span class="paren5">(<span class="code">type value</span>)</span>
            <span class="paren5">(<span class="code"><i><span class="symbol">if</span></i><span class="paren6">(<span class="code">listp value</span>)</span>
              <span class="paren6">(<span class="code">rec<span class="paren1">(<span class="code">cdr type</span>)</span><span class="paren1">(<span class="code">cdr value</span>)</span><span class="paren1">(<span class="code">list <span class="paren2">(<span class="code">car type</span>)</span></span>)</span></span>)</span>
              type</span>)</span></span>)</span>
          <span class="paren4">(<span class="code">rec<span class="paren5">(<span class="code">type value acc</span>)</span>
            <span class="paren5">(<span class="code"><i><span class="symbol">if</span></i> <span class="paren6">(<span class="code">endp value</span>)</span>
              <span class="paren6">(<span class="code">nreconc acc type</span>)</span>
              <span class="paren6">(<span class="code">body <span class="paren1">(<span class="code">car type</span>)</span><span class="paren1">(<span class="code">cdr type</span>)</span><span class="paren1">(<span class="code">car value</span>)</span><span class="paren1">(<span class="code">cdr value</span>)</span>acc</span>)</span></span>)</span></span>)</span>
          <span class="paren4">(<span class="code">body<span class="paren5">(<span class="code">type type-rest value value-rest acc</span>)</span>
            <span class="paren5">(<span class="code"><i><span class="symbol">if</span></i><span class="paren6">(<span class="code">eq '* type</span>)</span>
              <span class="paren6">(<span class="code">rec type-rest value-rest <span class="paren1">(<span class="code">push <span class="paren2">(<span class="code">class-name<span class="paren3">(<span class="code">class-of value</span>)</span></span>)</span>acc</span>)</span></span>)</span>
              <span class="paren6">(<span class="code">rec type-rest value-rest <span class="paren1">(<span class="code">push type acc</span>)</span></span>)</span></span>)</span></span>)</span>
            </span>)</span>
    `<span class="paren3">(<span class="code">,@<span class="paren4">(<span class="code">subseq form 0 2</span>)</span>
       <span class="paren4">(<span class="code">DECLARE,@<span class="paren5">(<span class="code">mapcar <span class="paren6">(<span class="code"><i><span class="symbol">lambda</span></i><span class="paren1">(<span class="code">value var</span>)</span>
                           <span class="paren1">(<span class="code"><i><span class="symbol">if</span></i><span class="paren2">(<span class="code">adv-p value</span>)</span>
                             <span class="paren2">(<span class="code"><i><span class="symbol">let</span></i><span class="paren3">(<span class="code"><span class="paren4">(<span class="code">type<span class="paren5">(<span class="code">data-type-of value</span>)</span></span>)</span></span>)</span>
                               <span class="paren3">(<span class="code"><i><span class="symbol">if</span></i><span class="paren4">(<span class="code">listp type</span>)</span>
                                 `<span class="paren4">(<span class="code">TYPE ,<span class="paren5">(<span class="code">actual-type type value</span>)</span>,var</span>)</span>
                                 `<span class="paren4">(<span class="code">TYPE ,type ,var</span>)</span></span>)</span></span>)</span>
                             `<span class="paren2">(<span class="code">TYPE ,<span class="paren3">(<span class="code">type-of value</span>)</span>,var</span>)</span></span>)</span></span>)</span>
                         values
                         <span class="paren6">(<span class="code">cadr form</span>)</span></span>)</span></span>)</span>
       ,@<span class="paren4">(<span class="code">subseq form 2</span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<p>インスタンスメソッドが持つ型シグネチャと型情報が一致するかチェックする。
<code>CHECK-TYPE</code>同様返り値に意味はない。
可読性向上のために利便性の高いAPIを提供する役目を担う。</p>

<pre><code><span class="code"><span class="comment">;;;; CHECK-SIGNATURE
</span><span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> check-signature<span class="paren2">(<span class="code">$pattern $type*</span>)</span>
  <span class="paren2">(<span class="code"><i><span class="symbol">labels</span></i><span class="paren3">(<span class="code"><span class="paren4">(<span class="code">rec<span class="paren5">(<span class="code">pattern type* acc</span>)</span>
            <span class="paren5">(<span class="code"><i><span class="symbol">if</span></i><span class="paren6">(<span class="code">endp pattern</span>)</span>
              <span class="paren6">(<span class="code"><i><span class="symbol">if</span></i><span class="paren1">(<span class="code">endp type*</span>)</span>
                T
                <span class="paren1">(<span class="code">error <span class="string">"Unmatch length ~S ~S"</span> $pattern $type*</span>)</span></span>)</span>
              <span class="paren6">(<span class="code"><i><span class="symbol">if</span></i><span class="paren1">(<span class="code">endp type*</span>)</span>
                <span class="paren1">(<span class="code">error <span class="string">"Unmatch length ~S ~S"</span> $pattern $type*</span>)</span>
                <span class="paren1">(<span class="code">body <span class="paren2">(<span class="code">car pattern</span>)</span><span class="paren2">(<span class="code">cdr pattern</span>)</span><span class="paren2">(<span class="code">car type*</span>)</span><span class="paren2">(<span class="code">cdr type*</span>)</span>acc</span>)</span></span>)</span></span>)</span></span>)</span>
          <span class="paren4">(<span class="code">body<span class="paren5">(<span class="code">pat pat-rest type type-rest acc</span>)</span>
            <span class="paren5">(<span class="code"><i><span class="symbol">let</span></i><span class="paren6">(<span class="code"><span class="paren1">(<span class="code">seen<span class="paren2">(<span class="code">assoc pat acc <span class="keyword">:test</span> #'equal</span>)</span></span>)</span></span>)</span>
              <span class="paren6">(<span class="code"><i><span class="symbol">if</span></i> seen
                <span class="paren1">(<span class="code"><i><span class="symbol">if</span></i><span class="paren2">(<span class="code">compatible-type-p type <span class="paren3">(<span class="code">cdr seen</span>)</span></span>)</span>
                  <span class="paren2">(<span class="code">rec pat-rest type-rest <span class="paren3">(<span class="code"><i><span class="symbol">progn</span></i> <span class="paren4">(<span class="code">pushnew type <span class="paren5">(<span class="code">cdr seen</span>)</span><span class="keyword">:test</span> #'equalp</span>)</span>
                                                 acc</span>)</span></span>)</span>
                  <span class="paren2">(<span class="code">error <span class="string">"Uncompatible type ~S ~S"</span>type seen</span>)</span></span>)</span>
                <span class="paren1">(<span class="code">rec pat-rest type-rest <span class="paren2">(<span class="code">push<span class="paren3">(<span class="code">%check pat type</span>)</span>acc</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>
          </span>)</span>
    <span class="paren3">(<span class="code">rec <span class="paren4">(<span class="code">cdr $pattern</span>)</span><span class="paren4">(<span class="code">cdr $type*</span>)</span>`<span class="paren4">(<span class="code">,<span class="paren5">(<span class="code">%check<span class="paren6">(<span class="code">car $pattern</span>)</span><span class="paren6">(<span class="code">car $type*</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<p>例えば<code>FIXNUM</code>は<code>INTEGER</code>のサブタイプである。
サブタイプは受け入れられるべきである。
それらをチェックするための述語。
これは利便性のためのAPIを担う。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> compatible-type-p<span class="paren2">(<span class="code">type type*</span>)</span>
  <span class="paren2">(<span class="code"><i><span class="symbol">loop</span></i> <span class="keyword">:for</span> t1 <span class="keyword">:in</span> type*
        <span class="keyword">:always</span> <span class="paren3">(<span class="code">%compatible-type-p t1 type</span>)</span></span>)</span></span>)</span></span></code></pre>

<p>実際の判定処理。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> %compatible-type-p<span class="paren2">(<span class="code">t1 t2</span>)</span>
  <span class="paren2">(<span class="code"><i><span class="symbol">if</span></i><span class="paren3">(<span class="code">constant-p t1</span>)</span>
    <span class="paren3">(<span class="code"><i><span class="symbol">if</span></i><span class="paren4">(<span class="code">constant-p t2</span>)</span>
      <span class="paren4">(<span class="code">%compatible-type-p <span class="paren5">(<span class="code">type-of<span class="paren6">(<span class="code">constant-value t1</span>)</span></span>)</span>
                          <span class="paren5">(<span class="code">type-of<span class="paren6">(<span class="code">constant-value t2</span>)</span></span>)</span></span>)</span>
      <span class="paren4">(<span class="code">typep <span class="paren5">(<span class="code">constant-value t1</span>)</span>t2</span>)</span></span>)</span>
    <span class="paren3">(<span class="code"><i><span class="symbol">if</span></i><span class="paren4">(<span class="code">constant-p t2</span>)</span>
      <span class="paren4">(<span class="code">typep <span class="paren5">(<span class="code">constant-value t2</span>)</span>t1</span>)</span>
      <span class="paren4">(<span class="code">subtypep t1 t2</span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<p>各シグネチャと型との整合性をチェックする。</p>

<pre><code>(defun %check(pattern type)
  (if(listp pattern)
    (if(eq 'function (car pattern))
      (cond
        ((constant-p type)
         (let((ftype(cdr(assoc 'ftype (nth-value 2 (introspect-environment:function-information (constant-value type)))))))
           (unify:unify pattern (subst '_ '* ftype))
           (list pattern ftype)))
        ((typep type '(cons (eql function) t))
         (unify:unify pattern (subst '_ '* type))
         (list pattern type))
        ((or (eq t type)(eq 'function type))
         (warn "Could not match ~S ~S"pattern type)
         (list pattern type))
        (t (error "%CHECK: Unknown type comes.~%TYPE: ~S" type)))
      (progn (unify:unify pattern (subst '_ '* type))
             (list pattern type)))
    (list pattern type)))</code></pre>

<p>型情報を基に、インターフェイスからラムダフォームを求める。</p>

<pre><code><span class="code"><span class="comment">;;;; GET-INSTANCE-LAMBDA
</span><span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> get-instance-lambda<span class="paren2">(<span class="code">interface type*</span>)</span>
  <span class="paren2">(<span class="code"><i><span class="symbol">if</span></i><span class="paren3">(<span class="code">every <span class="paren4">(<span class="code"><i><span class="symbol">lambda</span></i><span class="paren5">(<span class="code">x</span>)</span>
              <span class="paren5">(<span class="code">eq t x</span>)</span></span>)</span>
            type*</span>)</span>
    nil
    <span class="paren3">(<span class="code">or <span class="paren4">(<span class="code">compute-applicable-instance<span class="paren5">(<span class="code">collect-instance type* interface</span>)</span></span>)</span>
        <span class="paren4">(<span class="code">instance-default interface</span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<p>適応可能なインスタンスを集める。</p>

<pre><code><span class="code"><span class="comment">;;;; COLLECT-INSTANCE
</span><span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> collect-instance<span class="paren2">(<span class="code">type* interface</span>)</span>
  <span class="paren2">(<span class="code">remove-if-not <span class="paren3">(<span class="code"><i><span class="symbol">lambda</span></i><span class="paren4">(<span class="code">ts2</span>)</span>
                   <span class="paren4">(<span class="code">every #'%compatible-type-p type* ts2</span>)</span></span>)</span>
                 <span class="paren3">(<span class="code">instance-table interface</span>)</span>
                 <span class="keyword">:key</span> #'car</span>)</span></span>)</span></span></code></pre>

<p>最も特定的なインスタンスを求める。</p>

<pre><code><span class="code"><span class="comment">;;;; COMPUTE-APPLICABLE-INSTANCE
</span><span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> compute-applicable-instance<span class="paren2">(<span class="code">list</span>)</span>
  <span class="paren2">(<span class="code">cdar<span class="paren3">(<span class="code">sort-instance list</span>)</span></span>)</span></span>)</span>

<span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> sort-instance<span class="paren2">(<span class="code">list</span>)</span>
  <span class="paren2">(<span class="code"><i><span class="symbol">flet</span></i><span class="paren3">(<span class="code"><span class="paren4">(<span class="code">type&lt;<span class="paren5">(<span class="code">ts1 ts2</span>)</span>
          <span class="paren5">(<span class="code">every #'subtypep ts1 ts2</span>)</span></span>)</span></span>)</span>
    <span class="paren3">(<span class="code">sort list #'type&lt; <span class="keyword">:key</span> #'car</span>)</span></span>)</span></span>)</span></span></code></pre>

<p>インスタンスを定義する。</p>

<pre><code><span class="code"><span class="comment">;;;; DEFISTANCE
</span><span class="paren1">(<span class="code"><i><span class="symbol">defmacro</span></i> <i><span class="symbol">definstance</span></i><span class="paren2">(<span class="code">interface instance-lambda-list &amp;body body</span>)</span>
  <span class="paren2">(<span class="code"><i><span class="symbol">flet</span></i><span class="paren3">(<span class="code"><span class="paren4">(<span class="code">parse-lambda-list<span class="paren5">(<span class="code">lambda-list</span>)</span>
          <span class="paren5">(<span class="code"><i><span class="symbol">loop</span></i> <span class="keyword">:for</span> elt <span class="keyword">:in</span> lambda-list
                <span class="keyword">:collect</span> <span class="paren6">(<span class="code">car elt</span>)</span> <span class="keyword">:into</span> vars
                <span class="keyword">:collect</span> <span class="paren6">(<span class="code"><i><span class="symbol">let</span></i><span class="paren1">(<span class="code"><span class="paren2">(<span class="code">type<span class="paren3">(<span class="code">cadr elt</span>)</span></span>)</span></span>)</span>
                           <span class="paren1">(<span class="code"><i><span class="symbol">if</span></i><span class="paren2">(<span class="code">or <span class="paren3">(<span class="code">adt-p type</span>)</span>
                                  <span class="paren3">(<span class="code">find-class type nil</span>)</span></span>)</span>
                             type
                             <span class="paren2">(<span class="code">error <span class="string">"Invalid type"</span></span>)</span></span>)</span></span>)</span>
                <span class="keyword">:into</span> types
                <span class="keyword">:finally</span> <span class="paren6">(<span class="code">return <span class="paren1">(<span class="code">values vars types</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>
    <span class="paren3">(<span class="code">multiple-value-bind<span class="paren4">(<span class="code">vars types</span>)</span><span class="paren4">(<span class="code">parse-lambda-list instance-lambda-list</span>)</span>
      <span class="paren4">(<span class="code"><i><span class="symbol">let</span></i><span class="paren5">(<span class="code"><span class="paren6">(<span class="code">scs<span class="paren1">(<span class="code">type-direct-superclasses<span class="paren2">(<span class="code">get<span class="paren3">(<span class="code">instance-type-class interface</span>)</span>'type-class</span>)</span></span>)</span></span>)</span></span>)</span>
        <span class="paren5">(<span class="code">dolist<span class="paren6">(<span class="code">sc scs</span>)</span>
          <span class="paren6">(<span class="code">assert<span class="paren1">(<span class="code">or <span class="paren2">(<span class="code">get-instance-lambda sc types</span>)</span>
                     <span class="paren2">(<span class="code">instance-default sc</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>
      `<span class="paren4">(<span class="code"><i><span class="symbol">progn</span></i> <span class="paren5">(<span class="code">add-instance ',interface
                            ',types
                            '<span class="paren6">(<span class="code"><i><span class="symbol">lambda</span></i>,vars,@body</span>)</span></span>)</span>
              ',interface</span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<p>インターフェイスにインスタンスを登録する。</p>

<pre><code><span class="code"><span class="comment">;;;; ADD-INSTANCE
</span><span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> add-instance<span class="paren2">(<span class="code">interface type* lambda-form</span>)</span>
  <span class="paren2">(<span class="code">push<span class="paren3">(<span class="code">cons type* lambda-form</span>)</span><span class="paren3">(<span class="code">instance-table interface</span>)</span></span>)</span></span>)</span></span></code></pre>

<h3>type class</h3>

<pre><code><span class="code"><span class="keyword">class</span> <span class="variable">Eq</span> a <span class="keyword">where</span>
&nbsp;   <span class="paren1">(<span class="code"><span class="atom">==</span></span>)</span> <span class="keyword">::</span> a <span class="keyword">-&gt;</span> a <span class="keyword">-&gt;</span> <span class="variable">Bool</span>
&nbsp;   <span class="paren1">(<span class="code"><span class="atom">/=</span></span>)</span> <span class="keyword">::</span> a <span class="keyword">-&gt;</span> a <span class="keyword">-&gt;</span> <span class="variable">Bool</span>
&nbsp;   x <span class="atom">==</span> y <span class="keyword">=</span> not <span class="paren1">(<span class="code">x <span class="atom">/=</span> y</span>)</span>
&nbsp;   x <span class="atom">/=</span> y <span class="keyword">=</span> not <span class="paren1">(<span class="code">x <span class="atom">==</span> y</span>)</span></span></code></pre>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">define-type-class</span></i><span class="paren2">(<span class="code">eq a</span>)</span><span class="paren2">(<span class="code"></span>)</span>
  <span class="paren2">(<span class="code"><span class="paren3">(<span class="code">==<span class="paren4">(<span class="code">a a</span>)</span> boolean</span>)</span>
   <span class="paren3">(<span class="code">/==<span class="paren4">(<span class="code">a a</span>)</span> boolean</span>)</span></span>)</span>
  <span class="paren2">(<span class="code"><span class="keyword">:default</span> == <span class="paren3">(<span class="code">x y</span>)</span>
    <span class="paren3">(<span class="code">not <span class="paren4">(<span class="code">/== x y</span>)</span></span>)</span></span>)</span>
  <span class="paren2">(<span class="code"><span class="keyword">:default</span> /== <span class="paren3">(<span class="code">x y</span>)</span>
    <span class="paren3">(<span class="code">not <span class="paren4">(<span class="code">== x y</span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<h3>Trafic light</h3>

<pre><code><span class="code"><span class="keyword">data</span> <span class="variable">TrafficLight</span> <span class="keyword">=</span> <span class="variable">Red</span> <span class="keyword">|</span> <span class="variable">Yellow</span> <span class="keyword">|</span> <span class="variable">Green</span>

<span class="keyword">instance</span> <span class="variable">Eq</span> <span class="variable">TrafficLight</span> <span class="keyword">where</span>
&nbsp;   <span class="variable">Red</span> <span class="atom">==</span> <span class="variable">Red</span> <span class="keyword">=</span> <span class="variable">True</span>
&nbsp;   <span class="variable">Green</span> <span class="atom">==</span> <span class="variable">Green</span> <span class="keyword">=</span> <span class="variable">True</span>
&nbsp;   <span class="variable">Yellow</span> <span class="atom">==</span> <span class="variable">Yellow</span> <span class="keyword">=</span> <span class="variable">True</span>
&nbsp;   _ <span class="atom">==</span> _ <span class="keyword">=</span> <span class="variable">False</span>
<span class="keyword">instance</span> <span class="paren1">(<span class="code"><span class="variable">Eq</span> m</span>)</span> <span class="atom">=&gt;</span> <span class="variable">Eq</span> <span class="paren1">(<span class="code"><span class="variable">Maybe</span> m</span>)</span> <span class="keyword">where</span>
&nbsp;   <span class="variable">Just</span> x <span class="atom">==</span> <span class="variable">Just</span> y <span class="keyword">=</span> x <span class="atom">==</span> y
&nbsp;   <span class="variable">Nothing</span> <span class="atom">==</span> <span class="variable">Nothing</span> <span class="keyword">=</span> <span class="variable">True</span>
&nbsp;   _ <span class="atom">==</span> _ <span class="keyword">=</span> <span class="variable">False</span></span></code></pre>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">defdata</span></i> traffic-light<span class="paren2">(<span class="code"></span>)</span>
  <span class="keyword">:red</span> <span class="keyword">:yellow</span> <span class="keyword">:green</span></span>)</span>

<span class="paren1">(<span class="code"><i><span class="symbol">definstance</span></i> == <span class="paren2">(<span class="code"><span class="paren3">(<span class="code">a traffic-light</span>)</span><span class="paren3">(<span class="code">b traffic-light</span>)</span></span>)</span>
  <span class="paren2">(<span class="code">trivia:match*<span class="paren3">(<span class="code">a b</span>)</span>
    <span class="paren3">(<span class="code"><span class="paren4">(<span class="code"><span class="keyword">:red</span> <span class="keyword">:red</span></span>)</span>T</span>)</span>
    <span class="paren3">(<span class="code"><span class="paren4">(<span class="code"><span class="keyword">:green</span> <span class="keyword">:green</span></span>)</span>T</span>)</span>
    <span class="paren3">(<span class="code"><span class="paren4">(<span class="code"><span class="keyword">:yellow</span> <span class="keyword">:yellow</span></span>)</span>T</span>)</span>
    <span class="paren3">(<span class="code"><span class="paren4">(<span class="code">_ _</span>)</span> nil</span>)</span></span>)</span></span>)</span>

<span class="paren1">(<span class="code"><i><span class="symbol">definstance</span></i> == <span class="paren2">(<span class="code"><span class="paren3">(<span class="code">a <span class="paren4">(<span class="code">maybe *</span>)</span></span>)</span><span class="paren3">(<span class="code">b <span class="paren4">(<span class="code">maybe *</span>)</span></span>)</span></span>)</span>
  <span class="paren2">(<span class="code">trivia:match*<span class="paren3">(<span class="code">a b</span>)</span>
   <span class="paren3">(<span class="code"><span class="paren4">(<span class="code"><span class="keyword">:nothing</span> <span class="keyword">:nothing</span></span>)</span>T</span>)</span>
   <span class="paren3">(<span class="code"><span class="paren4">(<span class="code"><span class="paren5">(<span class="code">just x</span>)</span><span class="paren5">(<span class="code">just y</span>)</span></span>)</span><span class="paren4">(<span class="code">== x y</span>)</span></span>)</span>
   <span class="paren3">(<span class="code"><span class="paren4">(<span class="code">_ _</span>)</span>nil</span>)</span></span>)</span></span>)</span></span></code></pre>

<h2>7.9</h2>

<h3>Yes No</h3>

<pre><code><span class="code"><span class="keyword">class</span> <span class="variable">YesNo</span> a <span class="keyword">where</span>
&nbsp;   yesno <span class="keyword">::</span> a <span class="keyword">-&gt;</span> <span class="variable">Bool</span>

<span class="keyword">instance</span> <span class="variable">YesNo</span> <span class="variable">Int</span> <span class="keyword">where</span>
&nbsp;   yesno 0 <span class="keyword">=</span> <span class="variable">False</span>
&nbsp;   yesno _ <span class="keyword">=</span> <span class="variable">True</span>

<span class="keyword">instance</span> <span class="variable">YesNo</span> <span class="paren1">[<span class="code">a</span>)</span> <span class="keyword">where</span>
&nbsp;   yesno <span class="paren1">[<span class="code"></span>)</span> <span class="keyword">=</span> <span class="variable">False</span>
&nbsp;   yesno _ <span class="keyword">=</span> <span class="variable">True</span>

<span class="keyword">instance</span> <span class="variable">YesNo</span> bool <span class="keyword">where</span>
&nbsp;   yesno <span class="keyword">=</span> id

<span class="keyword">instance</span> <span class="variable">YesNo</span> <span class="paren1">(<span class="code"><span class="variable">Maybe</span> a</span>)</span> <span class="keyword">where</span>
&nbsp;   yesno <span class="paren1">(<span class="code">just _</span>)</span> <span class="keyword">=</span> <span class="variable">True</span>
&nbsp;   yesno <span class="variable">Nothing</span> <span class="keyword">=</span> <span class="variable">False</span>

<span class="keyword">instance</span> <span class="variable">YesNo</span> <span class="paren1">(<span class="code"><span class="variable">Tree</span> a</span>)</span> <span class="keyword">where</span>
&nbsp;   yesno <span class="variable">EmptyTree</span> <span class="keyword">=</span> <span class="variable">False</span>
&nbsp;   yesno _ <span class="keyword">=</span> <span class="variable">True</span>

<span class="keyword">instance</span> <span class="variable">YesNo</span> <span class="variable">TrafficLight</span> <span class="keyword">where</span>
&nbsp;   yesno <span class="variable">Red</span> <span class="keyword">=</span> <span class="variable">False</span>
&nbsp;   yesno _ <span class="keyword">=</span> <span class="variable">True</span></span></code></pre>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">define-type-class</span></i><span class="paren2">(<span class="code">yes-no a</span>)</span><span class="paren2">(<span class="code"></span>)</span>
  <span class="paren2">(<span class="code"><span class="paren3">(<span class="code">yes-no<span class="paren4">(<span class="code">a</span>)</span>boolean</span>)</span></span>)</span></span>)</span>

<span class="paren1">(<span class="code"><i><span class="symbol">definstance</span></i> yes-no <span class="paren2">(<span class="code"><span class="paren3">(<span class="code">a fixnum</span>)</span></span>)</span>
  <span class="paren2">(<span class="code">not<span class="paren3">(<span class="code">zerop a</span>)</span></span>)</span></span>)</span>

<span class="paren1">(<span class="code"><i><span class="symbol">definstance</span></i> yes-no <span class="paren2">(<span class="code"><span class="paren3">(<span class="code">a list</span>)</span></span>)</span>
  a</span>)</span>

<span class="paren1">(<span class="code"><i><span class="symbol">definstance</span></i> yes-no <span class="paren2">(<span class="code"><span class="paren3">(<span class="code">a symbol</span>)</span></span>)</span>
  a</span>)</span>

<span class="paren1">(<span class="code"><i><span class="symbol">definstance</span></i> yes-no <span class="paren2">(<span class="code"><span class="paren3">(<span class="code">a <span class="paren4">(<span class="code">maybe *</span>)</span></span>)</span></span>)</span>
  <span class="paren2">(<span class="code">unless<span class="paren3">(<span class="code">eq <span class="keyword">:nothing</span> a</span>)</span>
    T</span>)</span></span>)</span>

<span class="paren1">(<span class="code"><i><span class="symbol">definstance</span></i> yes-no <span class="paren2">(<span class="code"><span class="paren3">(<span class="code">a traffic-light</span>)</span></span>)</span>
  <span class="paren2">(<span class="code">unless<span class="paren3">(<span class="code">eq <span class="keyword">:red</span> a</span>)</span>
    T</span>)</span></span>)</span></span></code></pre>

<h3>Compare</h3>

<p>さて、欠陥だらけではあるが、ひとまず動く<code>DEFINE-TYPE-CLASS</code>が手に入っているので、これで後回しにしていたTODOを回収できる。
すなわち、<code>compare</code>の実装と、<code>week</code>データ型の実装とである。</p>

<pre><code><span class="code"><span class="keyword">data</span> <span class="variable">Bool</span> <span class="keyword">=</span> <span class="variable">Fails</span> <span class="keyword">|</span> <span class="variable">True</span> <span class="keyword">deriving</span> <span class="paren1">(<span class="code"><span class="variable">Ord</span></span>)</span>

<span class="function">ghci</span><span class="atom">&gt;</span> <span class="variable">True</span> <span class="atom">`compare`</span> <span class="variable">False</span>
<span class="variable">GT</span>
<span class="function">ghci</span><span class="atom">&gt;</span> <span class="variable">True</span> <span class="atom">&gt;</span> <span class="variable">False</span>
<span class="variable">True</span>
<span class="function">ghci</span><span class="atom">&gt;</span> <span class="variable">True</span> <span class="atom">&lt;</span> <span class="variable">False</span>
<span class="variable">False</span></span></code></pre>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">defdata</span></i> bool <span class="paren2">(<span class="code"></span>)</span> <span class="keyword">:false</span> <span class="keyword">:true</span></span>)</span>

<span class="paren1">(<span class="code"><i><span class="symbol">define-type-class</span></i><span class="paren2">(<span class="code">ord a</span>)</span><span class="paren2">(<span class="code"></span>)</span>
  <span class="paren2">(<span class="code"><span class="paren3">(<span class="code">ord<span class="paren4">(<span class="code">a</span>)</span>integer</span>)</span></span>)</span>
  <span class="paren2">(<span class="code"><span class="keyword">:default</span> ord<span class="paren3">(<span class="code">x</span>)</span>
    <span class="paren3">(<span class="code">data-order x</span>)</span></span>)</span></span>)</span>

<span class="paren1">(<span class="code"><i><span class="symbol">definstance</span></i> ord <span class="paren2">(<span class="code"><span class="paren3">(<span class="code">a number</span>)</span></span>)</span>
  a</span>)</span>
<span class="paren1">(<span class="code"><i><span class="symbol">definstance</span></i> ord <span class="paren2">(<span class="code"><span class="paren3">(<span class="code">a character</span>)</span></span>)</span>
  <span class="paren2">(<span class="code">char-code a</span>)</span></span>)</span>

<span class="paren1">(<span class="code"><i><span class="symbol">define-type-class</span></i><span class="paren2">(<span class="code">compare a</span>)</span><span class="paren2">(<span class="code">ord</span>)</span>
  <span class="paren2">(<span class="code"><span class="paren3">(<span class="code">compare<span class="paren4">(<span class="code">a a</span>)</span><span class="paren4">(<span class="code">member <span class="keyword">:eq</span> <span class="keyword">:lt</span> <span class="keyword">:gt</span></span>)</span></span>)</span>
   <span class="paren3">(<span class="code">lt<span class="paren4">(<span class="code">a a</span>)</span>boolean</span>)</span>
   <span class="paren3">(<span class="code">gt<span class="paren4">(<span class="code">a a</span>)</span>boolean</span>)</span>
   <span class="paren3">(<span class="code">lte<span class="paren4">(<span class="code">a a</span>)</span>boolean</span>)</span>
   <span class="paren3">(<span class="code">gte<span class="paren4">(<span class="code">a a</span>)</span>boolean</span>)</span></span>)</span>
  <span class="paren2">(<span class="code"><span class="keyword">:default</span> compare <span class="paren3">(<span class="code">x y</span>)</span>
    <span class="paren3">(<span class="code">compare <span class="paren4">(<span class="code">ord x</span>)</span><span class="paren4">(<span class="code">ord y</span>)</span></span>)</span></span>)</span>
  <span class="paren2">(<span class="code"><span class="keyword">:default</span> lt <span class="paren3">(<span class="code">x y</span>)</span>
    <span class="paren3">(<span class="code">&lt; <span class="paren4">(<span class="code">ord x</span>)</span><span class="paren4">(<span class="code">ord y</span>)</span></span>)</span></span>)</span>
  <span class="paren2">(<span class="code"><span class="keyword">:default</span> gt <span class="paren3">(<span class="code">x y</span>)</span>
    <span class="paren3">(<span class="code">&gt; <span class="paren4">(<span class="code">ord x</span>)</span><span class="paren4">(<span class="code">ord y</span>)</span></span>)</span></span>)</span>
  <span class="paren2">(<span class="code"><span class="keyword">:default</span> lte <span class="paren3">(<span class="code">x y</span>)</span>
    <span class="paren3">(<span class="code">&lt;= <span class="paren4">(<span class="code">ord x</span>)</span><span class="paren4">(<span class="code">ord y</span>)</span></span>)</span></span>)</span>
  <span class="paren2">(<span class="code"><span class="keyword">:default</span> gte <span class="paren3">(<span class="code">x y</span>)</span>
    <span class="paren3">(<span class="code">&gt;= <span class="paren4">(<span class="code">ord x</span>)</span><span class="paren4">(<span class="code">ord y</span>)</span></span>)</span></span>)</span></span>)</span>

<span class="paren1">(<span class="code"><i><span class="symbol">definstance</span></i> compare<span class="paren2">(<span class="code"><span class="paren3">(<span class="code">a number</span>)</span><span class="paren3">(<span class="code">b number</span>)</span></span>)</span>
  <span class="paren2">(<span class="code"><i><span class="symbol">cond</span></i>
    <span class="paren3">(<span class="code"><span class="paren4">(<span class="code">= a b</span>)</span><span class="keyword">:eq</span></span>)</span>
    <span class="paren3">(<span class="code"><span class="paren4">(<span class="code">&lt; a b</span>)</span><span class="keyword">:lt</span></span>)</span>
    <span class="paren3">(<span class="code">t <span class="keyword">:gt</span></span>)</span></span>)</span></span>)</span>

cl-user&gt; <span class="paren1">(<span class="code">compare <span class="keyword">:true</span> <span class="keyword">:false</span></span>)</span>
:GT
cl-user&gt; <span class="paren1">(<span class="code">gt <span class="keyword">:true</span> <span class="keyword">:false</span></span>)</span>
T
cl-user&gt; <span class="paren1">(<span class="code">lt <span class="keyword">:true</span> <span class="keyword">:false</span></span>)</span>
NIL</span></code></pre>

<pre><code><span class="code"><span class="keyword">data</span> <span class="variable">Day</span> <span class="keyword">=</span> <span class="variable">Monday</span> <span class="keyword">|</span> <span class="variable">Tuesday</span> <span class="keyword">|</span> <span class="variable">Wednesday</span> <span class="keyword">|</span> <span class="variable">Thursday</span> <span class="keyword">|</span> <span class="variable">Friday</span> <span class="keyword">|</span> <span class="variable">Saturday</span> <span class="keyword">|</span> <span class="variable">Sunday</span>
&nbsp;            <span class="keyword">deriving</span> <span class="paren1">(<span class="code"><span class="variable">Eq,</span> <span class="variable">Ord,</span> <span class="variable">Show,</span> <span class="variable">Read,</span> <span class="variable">Bounded,</span> <span class="variable">Enum</span></span>)</span></span></code></pre>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">defdata</span></i> week <span class="paren2">(<span class="code"></span>)</span>
  <span class="keyword">:monday</span> <span class="keyword">:tuesday</span> <span class="keyword">:wednesday</span> <span class="keyword">:thursday</span> <span class="keyword">:friday</span> <span class="keyword">:saturday</span> <span class="keyword">:sunday</span></span>)</span>

<span class="paren1">(<span class="code"><i><span class="symbol">define-type-class</span></i><span class="paren2">(<span class="code">bounded a</span>)</span><span class="paren2">(<span class="code"></span>)</span>
  <span class="paren2">(<span class="code"><span class="paren3">(<span class="code">min-bound<span class="paren4">(<span class="code">a</span>)</span>fixnum</span>)</span>
   <span class="paren3">(<span class="code">max-bound<span class="paren4">(<span class="code">a</span>)</span>fixnum</span>)</span></span>)</span>
  <span class="paren2">(<span class="code"><span class="keyword">:default</span> min-bound<span class="paren3">(<span class="code">x</span>)</span>
    <span class="paren3">(<span class="code">cadr<span class="paren4">(<span class="code">introspect-environment:typexpand-1 x</span>)</span></span>)</span></span>)</span>
  <span class="paren2">(<span class="code"><span class="keyword">:default</span> max-bound<span class="paren3">(<span class="code">x</span>)</span>
    <span class="paren3">(<span class="code">car<span class="paren4">(<span class="code">last<span class="paren5">(<span class="code">introspect-environment:typexpand-1 x</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>

<span class="paren1">(<span class="code"><i><span class="symbol">define-type-class</span></i><span class="paren2">(<span class="code">enum a</span>)</span><span class="paren2">(<span class="code"></span>)</span>
  <span class="paren2">(<span class="code"><span class="paren3">(<span class="code">succ<span class="paren4">(<span class="code">a</span>)</span>a</span>)</span>
   <span class="paren3">(<span class="code">pred<span class="paren4">(<span class="code">a</span>)</span>a</span>)</span></span>)</span>
  <span class="paren2">(<span class="code"><span class="keyword">:default</span> succ <span class="paren3">(<span class="code">x</span>)</span>
    <span class="paren3">(<span class="code">cadr <span class="paren4">(<span class="code">nth <span class="paren5">(<span class="code">1+<span class="paren6">(<span class="code">data-order x</span>)</span></span>)</span>
               <span class="paren5">(<span class="code">cdr<span class="paren6">(<span class="code">introspect-environment:typexpand-1<span class="paren1">(<span class="code">data-type-of x</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>
  <span class="paren2">(<span class="code"><span class="keyword">:default</span> pred <span class="paren3">(<span class="code">x</span>)</span>
    <span class="paren3">(<span class="code">cadr <span class="paren4">(<span class="code">nth <span class="paren5">(<span class="code">1-<span class="paren6">(<span class="code">data-order x</span>)</span></span>)</span>
               <span class="paren5">(<span class="code">cdr<span class="paren6">(<span class="code">introspect-environment:typexpand-1<span class="paren1">(<span class="code">data-type-of x</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<p>これでおよそ期待通りの振る舞いをしてくれる。</p>

<pre><code><span class="code"><span class="function">ghci</span><span class="atom">&gt;</span> <span class="variable">Wednesday</span>
<span class="variable">Wednesday</span>
<span class="function">ghci</span><span class="atom">&gt;</span> show <span class="variable">Wednesday</span>
<span class="string">"Wednesday"</span>
<span class="function">ghci</span><span class="atom">&gt;</span> read <span class="string">"Saturday"</span> <span class="keyword">::</span> <span class="variable">Day</span>
<span class="variable">Saturday</span></span></code></pre>

<pre><code><span class="code">cl-user&gt; :wednesday
:WEDNESDAY
cl-user&gt; <span class="paren1">(<span class="code">princ-to-string <span class="keyword">:wednesday</span></span>)</span>
"WEDNESDAY"
cl-user&gt; <span class="paren1">(<span class="code">read-from-string <span class="string">":saturday"</span></span>)</span>
:SATURDAY</span></code></pre>

<pre><code><span class="code"><span class="function">ghci</span><span class="atom">&gt;</span> <span class="variable">Saturday</span> <span class="atom">==</span> <span class="variable">Sunday</span>
<span class="variable">False</span>
<span class="function">ghci</span><span class="atom">&gt;</span> <span class="variable">Saturday</span> <span class="atom">==</span> <span class="variable">Saturday</span>
<span class="variable">True</span>
<span class="function">ghci</span><span class="atom">&gt;</span> <span class="variable">Saturday</span> <span class="atom">&gt;</span> <span class="variable">Friday</span>
<span class="variable">True</span>
<span class="function">ghci</span><span class="atom">&gt;</span> <span class="variable">Monday</span> <span class="atom">`compare`</span> <span class="variable">Wednesday</span>
<span class="variable">LT</span></span></code></pre>

<pre><code><span class="code">cl-user&gt; <span class="paren1">(<span class="code">eq <span class="keyword">:saturday</span> <span class="keyword">:sunday</span></span>)</span>
NIL
cl-user&gt; <span class="paren1">(<span class="code">eq <span class="keyword">:saturday</span> <span class="keyword">:saturday</span></span>)</span>
T
cl-user&gt; <span class="paren1">(<span class="code">gt <span class="keyword">:saturday</span> <span class="keyword">:friday</span></span>)</span>
T
cl-user&gt; <span class="paren1">(<span class="code">compare <span class="keyword">:monday</span> <span class="keyword">:wednesday</span></span>)</span>
:LT</span></code></pre>

<pre><code><span class="code"><span class="function">ghci</span><span class="atom">&gt;</span> minBound <span class="keyword">::</span> <span class="variable">Day</span>
<span class="variable">Monday</span>
<span class="function">ghci</span><span class="atom">&gt;</span> maxBound <span class="keyword">::</span> <span class="variable">Day</span>
<span class="variable">Sunday</span></span></code></pre>

<pre><code><span class="code">cl-user&gt; <span class="paren1">(<span class="code">min-bound 'week</span>)</span>
<span class="paren1">(<span class="code">EQL <span class="keyword">:MONDAY</span></span>)</span>
cl-user&gt; <span class="paren1">(<span class="code">max-bound 'week</span>)</span>
<span class="paren1">(<span class="code">EQL <span class="keyword">:SUNDAY</span></span>)</span></span></code></pre>

<pre><code><span class="code"><span class="function">ghci</span><span class="atom">&gt;</span> succ <span class="variable">Monday</span>
<span class="variable">Tuesday</span>
<span class="function">ghci</span><span class="atom">&gt;</span> pred <span class="variable">Saturday</span>
<span class="variable">Friday</span></span></code></pre>

<pre><code><span class="code">cl-user&gt; <span class="paren1">(<span class="code">succ <span class="keyword">:monday</span></span>)</span>
:TUESDAY
cl-user&gt; <span class="paren1">(<span class="code">pred <span class="keyword">:saturday</span></span>)</span>
:FRIDAY</span></code></pre>

<p>欠点は<code>:deriving</code>をサポートしていないところだ。</p>

<h2>7.10</h2>

<h3>Functor</h3>

<pre><code><span class="code"><span class="keyword">class</span> <span class="variable">Functor</span> f <span class="keyword">where</span>
&nbsp;   fmap <span class="keyword">::</span> <span class="paren1">(<span class="code">a <span class="keyword">-&gt;</span> b</span>)</span> <span class="keyword">-&gt;</span> f a <span class="keyword">-&gt;</span> f b

<span class="keyword">instance</span> <span class="variable">Functor</span> <span class="paren1">[<span class="code"></span>]</span> <span class="keyword">where</span>
&nbsp; fmap <span class="keyword">=</span> map</span></code></pre>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">define-type-class</span></i><span class="paren2">(<span class="code">functor f</span>)</span><span class="paren2">(<span class="code"></span>)</span>
  <span class="paren2">(<span class="code"><span class="paren3">(<span class="code">fmap<span class="paren4">(<span class="code"><span class="paren5">(<span class="code"><i><span class="symbol">function</span></i><span class="paren6">(<span class="code">a</span>)</span>b</span>)</span><span class="paren5">(<span class="code">f a</span>)</span></span>)</span><span class="paren4">(<span class="code">f b</span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<p>ファンクタも、およそそのまま再現できる。
大きな違いは関数の型を上手く表せない点だろう。</p>

<p>Common Lispのラムダリストはとても強力で、<code>&amp;REST</code>や<code>&amp;KEY</code>、<code>&amp;OPTIONAL</code>無しにどうやってコードを書けば良いんだ、と思ってしまうほどであるが、その代償として、関数の型は上手く表すことが出来なくなってしまっている。</p>

<p>特に関数を受け取る高階関数を書くにあたり、受け取る関数の型を上手く書けないのは割と辛い。
この点はHaskellが非常に羨ましく思える。
カリー化に伴う制約と、ラムダリストの便利さと、天秤にかけるならどちらに傾くだろうか。</p>

<h3>Maybe</h3>

<pre><code><span class="code"><span class="keyword">instance</span> <span class="variable">Functor</span> <span class="variable">Maybe</span> <span class="keyword">where</span>
&nbsp;   fmap f <span class="paren1">(<span class="code">just x</span>)</span> <span class="keyword">=</span> <span class="variable">Just</span> <span class="paren1">(<span class="code">f x</span>)</span>
&nbsp;   fmap f <span class="variable">Nothing</span> <span class="keyword">=</span> <span class="variable">Nothing</span></span></code></pre>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">definstance</span></i> fmap <span class="paren2">(<span class="code"><span class="paren3">(<span class="code">f <i><span class="symbol">function</span></i></span>)</span><span class="paren3">(<span class="code">m <span class="paren4">(<span class="code">maybe *</span>)</span></span>)</span></span>)</span>
  <span class="paren2">(<span class="code">trivia:match m
    <span class="paren3">(<span class="code"><span class="paren4">(<span class="code">just x</span>)</span><span class="paren4">(<span class="code">just<span class="paren5">(<span class="code">funcall f x</span>)</span></span>)</span></span>)</span>
    <span class="paren3">(<span class="code"><span class="keyword">:nothing</span> <span class="keyword">:nothing</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<h3>Tree</h3>

<h3>Either</h3>

<pre><code><span class="code"><span class="keyword">instance</span> <span class="variable">Functor</span> <span class="paren1">(<span class="code"><span class="variable">Either</span> a</span>)</span> <span class="keyword">where</span>
&nbsp; fmap f <span class="paren1">(<span class="code"><span class="variable">Right</span> x</span>)</span> <span class="keyword">=</span> <span class="variable">Right</span> <span class="paren1">(<span class="code">f x</span>)</span>
&nbsp; fmap f <span class="paren1">(<span class="code"><span class="variable">Left</span> x</span>)</span> <span class="keyword">=</span> <span class="variable">Left</span> x</span></code></pre>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">definstance</span></i> fmap<span class="paren2">(<span class="code"><span class="paren3">(<span class="code">f <i><span class="symbol">function</span></i></span>)</span><span class="paren3">(<span class="code">e <span class="paren4">(<span class="code">either *</span>)</span></span>)</span></span>)</span>
  <span class="paren2">(<span class="code">trivia:ematch e
    <span class="paren3">(<span class="code"><span class="paren4">(<span class="code">right x</span>)</span><span class="paren4">(<span class="code">right<span class="paren5">(<span class="code">funcall f x</span>)</span></span>)</span></span>)</span>
    <span class="paren3">(<span class="code"><span class="paren4">(<span class="code">left _</span>)</span> e</span>)</span></span>)</span></span>)</span></span></code></pre>

    </MAIN>
    <FOOTER><A HREF='../indexes/index.html'>Index</A></FOOTER>
  </BODY>
</HTML>